<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>psyplot.data &mdash; psyplot 1.4.2+21.g131e7dc documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/psyplot.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> psyplot
            <img src="../../_static/psyplot.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.4.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About psyplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference external" href="https://psyplot.github.io/examples/">Example Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../projects.html">Subprojects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accessors.html">xarray Accessors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plugins.html">Psyplot plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../command_line.html">Command line usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develop/index.html">Developers guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing to psyplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/psyplot.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../todos.html">ToDos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">psyplot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
          <li><a href="../psyplot.html">psyplot</a> &raquo;</li>
      <li>psyplot.data</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for psyplot.data</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Data management core routines of psyplot.&quot;&quot;&quot;</span>

<span class="c1"># Disclaimer</span>
<span class="c1"># ----------</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2021 Helmholtz-Zentrum Hereon</span>
<span class="c1"># Copyright (C) 2020-2021 Helmholtz-Zentrum Geesthacht</span>
<span class="c1"># Copyright (C) 2016-2021 University of Lausanne</span>
<span class="c1">#</span>
<span class="c1"># This file is part of psyplot and is released under the GNU LGPL-3.O license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License version 3.0 as</span>
<span class="c1"># published by the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU LGPL-3.0 license for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU LGPL-3.0 license</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">import_module</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">starmap</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">xarray.core.utils</span> <span class="kn">import</span> <span class="n">NDArrayMixin</span>
<span class="kn">from</span> <span class="nn">xarray.core.formatting</span> <span class="kn">import</span> <span class="n">first_n_items</span><span class="p">,</span> <span class="n">format_item</span>

<span class="kn">import</span> <span class="nn">xarray.backends.api</span> <span class="k">as</span> <span class="nn">xarray_api</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">to_datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">psyplot.config.rcsetup</span> <span class="kn">import</span> <span class="n">rcParams</span><span class="p">,</span> <span class="n">safe_list</span>
<span class="kn">from</span> <span class="nn">psyplot.docstring</span> <span class="kn">import</span> <span class="n">dedent</span><span class="p">,</span> <span class="n">docstrings</span>
<span class="kn">from</span> <span class="nn">psyplot.compat.pycompat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="nb">zip</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">isstring</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">getcwd</span><span class="p">,</span>
    <span class="n">Queue</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">psyplot.warning</span> <span class="kn">import</span> <span class="n">PsyPlotRuntimeWarning</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">import</span> <span class="nn">psyplot.utils</span> <span class="k">as</span> <span class="nn">utils</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dask</span>
    <span class="n">with_dask</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">with_dask</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">xarray.backends.plugins</span> <span class="k">as</span> <span class="nn">xr_plugins</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">xr_plugins</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>


<span class="c1"># No data variable. This is used for filtering if an attribute could not have</span>
<span class="c1"># been accessed</span>
<span class="n">_NODATA</span> <span class="o">=</span> <span class="nb">object</span>


<span class="n">VARIABLELABEL</span> <span class="o">=</span> <span class="s1">&#39;variable&#39;</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">_ds_counter</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">xr_version</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">_no_auto_update_getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:class:`bool`. Boolean controlling whether the :meth:`start_update`</span>
<span class="sd">    method is automatically called by the :meth:`update` method</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    You can disable the automatic update via</span>

<span class="sd">        &gt;&gt;&gt; with data.no_auto_update:</span>
<span class="sd">        ...     data.update(time=1)</span>
<span class="sd">        ...     data.start_update()</span>

<span class="sd">    To permanently disable the automatic update, simply set</span>

<span class="sd">        &gt;&gt;&gt; data.no_auto_update = True</span>
<span class="sd">        &gt;&gt;&gt; data.update(time=1)</span>
<span class="sd">        &gt;&gt;&gt; data.no_auto_update = False  # reenable automatical update&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_no_auto_update&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_auto_update</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_auto_update</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_TempBool</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_auto_update</span>


<span class="k">def</span> <span class="nf">_infer_interval_breaks</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; _infer_interval_breaks(np.arange(5))</span>
<span class="sd">    array([-0.5,  0.5,  1.5,  2.5,  3.5,  4.5])</span>

<span class="sd">    Taken from xarray.plotting.plot module</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">coord</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">deltas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">deltas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[</span><span class="n">first</span><span class="p">],</span> <span class="n">coord</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">deltas</span><span class="p">,</span> <span class="p">[</span><span class="n">last</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_get_variable_names</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the variable names of an array&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">VARIABLELABEL</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">VARIABLELABEL</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span>


<span class="k">def</span> <span class="nf">_get_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return all dimensions but the :attr:`VARIABLELABEL`&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">VARIABLELABEL</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_open_store</span><span class="p">(</span><span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">import_module</span><span class="p">(</span><span class="n">store_mod</span><span class="p">),</span> <span class="n">store_cls</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">import_module</span><span class="p">(</span><span class="n">store_mod</span><span class="p">),</span> <span class="n">store_cls</span><span class="p">)(</span><span class="n">fname</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fix_times</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
    <span class="c1"># xarray 0.16 fails with pandas 1.1.0 for datetime, see</span>
    <span class="c1"># https://github.com/pydata/xarray/issues/4283</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dims</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="n">dims</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">([</span><span class="n">val</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="setup_coords"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.setup_coords">[docs]</a><span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;setup_coords&#39;</span><span class="p">)</span>
<span class="nd">@dedent</span>
<span class="k">def</span> <span class="nf">setup_coords</span><span class="p">(</span><span class="n">arr_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="p">[],</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets up the arr_names dictionary for the plot</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr_names: string, list of strings or dictionary</span>
<span class="sd">        Set the unique array names of the resulting arrays and (optionally)</span>
<span class="sd">        dimensions.</span>

<span class="sd">        - if string: same as list of strings (see below). Strings may</span>
<span class="sd">          include {0} which will be replaced by a counter.</span>
<span class="sd">        - list of strings: those will be used for the array names. The final</span>
<span class="sd">          number of dictionaries in the return depend in this case on the</span>
<span class="sd">          `dims` and ``**furtherdims``</span>
<span class="sd">        - dictionary:</span>
<span class="sd">          Then nothing happens and an :class:`OrderedDict` version of</span>
<span class="sd">          `arr_names` is returned.</span>
<span class="sd">    sort: list of strings</span>
<span class="sd">        This parameter defines how the dictionaries are ordered. It has no</span>
<span class="sd">        effect if `arr_names` is a dictionary (use a</span>
<span class="sd">        :class:`~collections.OrderedDict` for that). It can be a list of</span>
<span class="sd">        dimension strings matching to the dimensions in `dims` for the</span>
<span class="sd">        variable.</span>
<span class="sd">    dims: dict</span>
<span class="sd">        Keys must be variable names of dimensions (e.g. time, level, lat or</span>
<span class="sd">        lon) or &#39;name&#39; for the variable name you want to choose.</span>
<span class="sd">        Values must be values of that dimension or iterables of the values</span>
<span class="sd">        (e.g. lists). Note that strings will be put into a list.</span>
<span class="sd">        For example dims = {&#39;name&#39;: &#39;t2m&#39;, &#39;time&#39;: 0} will result in one plot</span>
<span class="sd">        for the first time step, whereas dims = {&#39;name&#39;: &#39;t2m&#39;, &#39;time&#39;: [0, 1]}</span>
<span class="sd">        will result in two plots, one for the first (time == 0) and one for the</span>
<span class="sd">        second (time == 1) time step.</span>
<span class="sd">    ``**kwargs``</span>
<span class="sd">        The same as `dims` (those will update what is specified in `dims`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ~collections.OrderedDict</span>
<span class="sd">        A mapping from the keys in `arr_names` and to dictionaries. Each</span>
<span class="sd">        dictionary corresponds defines the coordinates of one data array to</span>
<span class="sd">        load&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">arr_names</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># ValueError for cyordereddict, TypeError for collections.OrderedDict</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="n">arr_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr_names</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;arr</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">isstring</span><span class="p">(</span><span class="n">arr_names</span><span class="p">):</span>
        <span class="n">arr_names</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">arr_names</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">sorted_dims</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">sorted_dims</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">sorted_dims</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># make sure, it is first sorted for the variable names</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">sorted_dims</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dims</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">sorted_dims</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">sorted_dims</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">sorted_dims</span><span class="p">):</span>
        <span class="n">sorted_dims</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">safe_list</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">([</span>
        <span class="p">(</span><span class="n">arr_name</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sorted_dims</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">dim_tuple</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">dim_tuple</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="n">arr_names</span><span class="p">,</span> <span class="n">product</span><span class="p">(</span>
                <span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">sorted_dims</span><span class="o">.</span><span class="n">values</span><span class="p">()))))])</span></div>


<div class="viewcode-block" id="to_slice"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.to_slice">[docs]</a><span class="k">def</span> <span class="nf">to_slice</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test whether `arr` is an integer array that can be replaced by a slice</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr: numpy.array</span>
<span class="sd">        Numpy integer array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slice or None</span>
<span class="sd">        If `arr` could be converted to an array, this is returned, otherwise</span>
<span class="sd">        `None` is returned</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_index_from_coord&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="get_index_from_coord"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.get_index_from_coord">[docs]</a><span class="k">def</span> <span class="nf">get_index_from_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">base_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to return the coordinate as integer, integer array or slice</span>

<span class="sd">    If `coord` is zero-dimensional, the corresponding integer in `base_index`</span>
<span class="sd">    will be supplied. Otherwise it is first tried to return a slice, if that</span>
<span class="sd">    does not work an integer array with the corresponding indices is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coord: xarray.Coordinate or xarray.Variable</span>
<span class="sd">        Coordinate to convert</span>
<span class="sd">    base_index: pandas.Index</span>
<span class="sd">        The base index from which the `coord` was extracted</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int, array of ints or slice</span>
<span class="sd">        The indexer that can be used to access the `coord` in the</span>
<span class="sd">        `base_index`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">values</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">coord</span>
    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">values</span><span class="p">[()])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_index</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">values</span> <span class="o">==</span> <span class="n">base_index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">base_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">values</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">to_slice</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">or</span> <span class="n">values</span></div>


<span class="c1">#: mapping that translates datetime format strings to regex patterns</span>
<span class="n">t_patterns</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;%Y&#39;</span><span class="p">:</span> <span class="s1">&#39;[0-9]</span><span class="si">{4}</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;%m&#39;</span><span class="p">:</span> <span class="s1">&#39;[0-9]{1,2}&#39;</span><span class="p">,</span>
        <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;[0-9]{1,2}&#39;</span><span class="p">,</span>
        <span class="s1">&#39;%H&#39;</span><span class="p">:</span> <span class="s1">&#39;[0-9]{1,2}&#39;</span><span class="p">,</span>
        <span class="s1">&#39;%M&#39;</span><span class="p">:</span> <span class="s1">&#39;[0-9]{1,2}&#39;</span><span class="p">,</span>
        <span class="s1">&#39;%S&#39;</span><span class="p">:</span> <span class="s1">&#39;[0-9]{1,2}&#39;</span><span class="p">,</span>
    <span class="p">}</span>


<div class="viewcode-block" id="get_tdata"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.get_tdata">[docs]</a><span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;get_tdata&#39;</span><span class="p">)</span>
<span class="nd">@dedent</span>
<span class="k">def</span> <span class="nf">get_tdata</span><span class="p">(</span><span class="n">t_format</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the time information from file names</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t_format: str</span>
<span class="sd">        The string that can be used to get the time information in the files.</span>
<span class="sd">        Any numeric datetime format string (e.g. %Y, %m, %H) can be used, but</span>
<span class="sd">        not non-numeric strings like %b, etc. See [1]_ for the datetime format</span>
<span class="sd">        strings</span>
<span class="sd">    files: list of str</span>
<span class="sd">        The that contain the time informations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.Index</span>
<span class="sd">        The time coordinate</span>
<span class="sd">    list of str</span>
<span class="sd">        The file names as they are sorten in the returned index</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://docs.python.org/2/library/datetime.html&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="mi">2</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Index</span>
    <span class="n">t_pattern</span> <span class="o">=</span> <span class="n">t_format</span>
    <span class="k">for</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">patt</span> <span class="ow">in</span> <span class="n">t_patterns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">t_pattern</span> <span class="o">=</span> <span class="n">t_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">patt</span><span class="p">)</span>
    <span class="n">t_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">t_pattern</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
        <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t_format</span><span class="p">)),</span>
            <span class="n">t_pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">f</span><span class="p">)))))</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>  <span class="c1"># sort according to time</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">files</span><span class="p">)[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time</span><span class="p">)[</span><span class="n">ind</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)),</span> <span class="n">files</span></div>


<span class="n">docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">to_netcdf</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                        <span class="s1">&#39;xarray.Dataset.to_netcdf&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="to_netcdf"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.to_netcdf">[docs]</a><span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
<span class="k">def</span> <span class="nf">to_netcdf</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Store the given dataset as a netCDF file</span>

<span class="sd">    This functions works essentially the same as the usual</span>
<span class="sd">    :meth:`xarray.Dataset.to_netcdf` method but can also encode absolute time</span>
<span class="sd">    units</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds: xarray.Dataset</span>
<span class="sd">        The dataset to store</span>
<span class="sd">    %(xarray.Dataset.to_netcdf.parameters)s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">to_update</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;day as %Y%m</span><span class="si">%d</span><span class="s1">.</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="n">to_update</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">AbsoluteTimeEncoder</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">attrs</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">encoding</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
            <span class="n">to_update</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">units</span>
    <span class="k">if</span> <span class="n">to_update</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">to_update</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xarray_api</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_get_fname_netCDF4</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to get the file name from the NetCDF4DataStore store&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s1">&#39;_filename&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_fname_scipy</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to get the file name from the ScipyDataStore store&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">store</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">filename</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_get_fname_nio</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to get the file name from the NioDataStore store&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">file</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">path</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="Signal"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.Signal">[docs]</a><span class="k">class</span> <span class="nc">Signal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Signal to connect functions to a specific event</span>

<span class="sd">    This class behaves almost similar to PyQt&#39;s</span>
<span class="sd">    :class:`PyQt4.QtCore.pyqtBoundSignal`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instance</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cls_signal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span> <span class="o">=</span> <span class="n">cls_signal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Signal.connect"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.Signal.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.emit"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.Signal.emit">[docs]</a>    <span class="k">def</span> <span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span> <span class="s1">&#39;block_signals&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="s1">&#39;block_signals&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Emitting signal </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[:]:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Calling </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.disconnect"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.Signal.disconnect">[docs]</a>    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disconnect a function call to the signal. If None, all connections</span>
<span class="sd">        are disconnected&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<span class="c1">#: functions to use to extract the file name from a data store</span>
<span class="n">get_fname_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_fname_netCDF4</span><span class="p">,</span> <span class="n">_get_fname_scipy</span><span class="p">,</span> <span class="n">_get_fname_nio</span><span class="p">]</span>


<div class="viewcode-block" id="get_filename_ds"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.get_filename_ds">[docs]</a><span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;get_filename_ds&#39;</span><span class="p">)</span>
<span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
<span class="k">def</span> <span class="nf">get_filename_ds</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the filename of the corresponding to a dataset</span>

<span class="sd">    This method returns the path to the `ds` or saves the dataset</span>
<span class="sd">    if there exists no filename</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds: xarray.Dataset</span>
<span class="sd">        The dataset you want the path information for</span>
<span class="sd">    dump: bool</span>
<span class="sd">        If True and the dataset has not been dumped so far, it is dumped to a</span>
<span class="sd">        temporary file or the one generated by `paths` is used</span>
<span class="sd">    paths: iterable or True</span>
<span class="sd">        An iterator over filenames to use if a dataset has no filename.</span>
<span class="sd">        If paths is ``True``, an iterator over temporary files will be</span>
<span class="sd">        created without raising a warning</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    ``**kwargs``</span>
<span class="sd">        Any other keyword for the :func:`to_netcdf` function</span>
<span class="sd">    %(xarray.Dataset.to_netcdf.parameters)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str or None</span>
<span class="sd">        None, if the dataset has not yet been dumped to the harddisk and</span>
<span class="sd">        `dump` is False, otherwise the complete the path to the input</span>
<span class="sd">        file</span>
<span class="sd">    str</span>
<span class="sd">        The module of the :class:`xarray.backends.common.AbstractDataStore`</span>
<span class="sd">        instance that is used to hold the data</span>
<span class="sd">    str</span>
<span class="sd">        The class name of the</span>
<span class="sd">        :class:`xarray.backends.common.AbstractDataStore` instance that is</span>
<span class="sd">        used to open the data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">NamedTemporaryFile</span>

    <span class="c1"># if already specified, return that filename</span>
    <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_filename</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">data_store</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dump_nc</span><span class="p">():</span>
        <span class="c1"># make sure that the data store is not closed by providing a</span>
        <span class="c1"># write argument</span>
        <span class="k">if</span> <span class="n">xr_version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;writer&#39;</span><span class="p">,</span> <span class="n">xarray_api</span><span class="o">.</span><span class="n">ArrayWriter</span><span class="p">())</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">to_netcdf</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># `writer` parameter was removed by</span>
            <span class="c1"># https://github.com/pydata/xarray/pull/2261</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;multifile&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">to_netcdf</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">store_mod</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">store_cls</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">_file_obj</span> <span class="o">=</span> <span class="n">store</span>
        <span class="k">return</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span>

    <span class="k">def</span> <span class="nf">tmp_it</span><span class="p">():</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.nc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">_legacy_get_filename_ds</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
        <span class="c1"># try to get the filename from the data store of the obj</span>
        <span class="c1">#</span>
        <span class="c1"># Outdated possibility since the backend plugin methodology of</span>
        <span class="c1"># xarray 0.18</span>
        <span class="k">if</span> <span class="n">store_mod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">_file_obj</span>
            <span class="c1"># try several engines</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s1">&#39;file_objs&#39;</span><span class="p">):</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">store_mod</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">store_cls</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">file_objs</span><span class="p">:</span>  <span class="c1"># mfdataset</span>
                    <span class="n">_fname</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">get_fname_funcs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">_fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">_fname</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">_fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">fname</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_fname</span><span class="p">)</span>
                                <span class="n">store_mod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
                                <span class="n">store_cls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                <span class="n">store_mod</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">store_mod</span><span class="p">)</span>
                <span class="n">store_cls</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">store_cls</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">get_fname_funcs</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">fname</span><span class="p">,</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">paths</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dump</span> <span class="ow">and</span> <span class="n">paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">tmp_it</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">paths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([</span><span class="n">paths</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
    <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">data_store</span>
    <span class="k">if</span> <span class="n">xr_plugins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fname</span><span class="p">,</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span> <span class="o">=</span> <span class="n">_legacy_get_filename_ds</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;source&quot;</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
        <span class="n">store_mod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">store_cls</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="c1"># check if paths is provided and if yes, save the file</span>
    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">paths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dump</span> <span class="ow">and</span> <span class="n">fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span> <span class="o">=</span> <span class="n">dump_nc</span><span class="p">()</span>

    <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">fname</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">data_store</span> <span class="o">=</span> <span class="p">(</span><span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fname</span><span class="p">,</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span></div>


<div class="viewcode-block" id="CFDecoder"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder">[docs]</a><span class="k">class</span> <span class="nc">CFDecoder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that interpretes the coordinates and attributes accordings to</span>
<span class="sd">    cf-conventions&quot;&quot;&quot;</span>

    <span class="n">_registry</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`logging.Logger` of this instance&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing...&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>

    <span class="nd">@logger</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;decoder.x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;decoder.y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;decoder.z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;decoder.t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<div class="viewcode-block" id="CFDecoder.register_decoder"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.register_decoder">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">register_decoder</span><span class="p">(</span><span class="n">decoder_class</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a new decoder</span>

<span class="sd">        This function registeres a decoder class to use</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decoder_class: type</span>
<span class="sd">            The class inherited from the :class:`CFDecoder`</span>
<span class="sd">        pos: int</span>
<span class="sd">            The position where to register the decoder (by default: the first</span>
<span class="sd">            position&quot;&quot;&quot;</span>
        <span class="n">CFDecoder</span><span class="o">.</span><span class="n">_registry</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">decoder_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFDecoder.can_decode"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.can_decode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder.can_decode&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parameters&#39;</span><span class="p">,</span>
                                                                <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">can_decode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class method to determine whether the object can be decoded by this</span>
<span class="sd">        decoder class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ds: xarray.Dataset</span>
<span class="sd">            The dataset that contains the given `var`</span>
<span class="sd">        var: xarray.Variable or xarray.DataArray</span>
<span class="sd">            The array to decode</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the decoder can decode the given array `var`. Otherwise</span>
<span class="sd">            False</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The default implementation returns True for any argument. Subclass this</span>
<span class="sd">        method to be specific on what type of data your decoder can decode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="CFDecoder.get_decoder"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_decoder">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_decoder</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class method to get the right decoder class that can decode the</span>
<span class="sd">        given dataset and variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.can_decode.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        CFDecoder</span>
<span class="sd">            The decoder for the given dataset that can decode the variable</span>
<span class="sd">            `var`&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">decoder_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_registry</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decoder_cls</span><span class="o">.</span><span class="n">can_decode</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">decoder_cls</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CFDecoder</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFDecoder.decode_coords"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.decode_coords">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder.decode_coords&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">decode_coords</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coordinates and bounds in a dataset</span>

<span class="sd">        This static method sets those coordinates and bounds that are marked</span>
<span class="sd">        marked in the netCDF attributes as coordinates in :attr:`ds` (without</span>
<span class="sd">        deleting them from the variable attributes because this information is</span>
<span class="sd">        necessary for visualizing the data correctly)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ds: xarray.Dataset</span>
<span class="sd">            The dataset to decode</span>
<span class="sd">        gridfile: str</span>
<span class="sd">            The path to a separate grid file or a xarray.Dataset instance which</span>
<span class="sd">            may store the coordinates used in `ds`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Dataset</span>
<span class="sd">            `ds` with additional coordinates&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">add_attrs</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;coordinates&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">extra_coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;coordinates&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;grid_mapping&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">extra_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;grid_mapping&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;bounds&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">extra_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">gridfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gridfile</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">gridfile</span> <span class="o">=</span> <span class="n">open_dataset</span><span class="p">(</span><span class="n">gridfile</span><span class="p">)</span>
        <span class="n">extra_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="n">add_attrs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">add_attrs</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gridfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">gridfile</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
                       <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_coords</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">xr_version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">set_coords</span><span class="p">(</span><span class="n">extra_coords</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span>
                          <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">extra_coords</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ds</span></div>

<div class="viewcode-block" id="CFDecoder.get_cell_node_coord"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_cell_node_coord">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder.is_unstructured&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span>
        <span class="s1">&#39;CFDecoder.get_cell_node_coord&#39;</span><span class="p">,</span>
        <span class="n">sections</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">get_cell_node_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the bounds in the variable attribute are triangular</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variable or xarray.DataArray</span>
<span class="sd">            The variable to check</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Coordinates to use. If None, the coordinates of the dataset in the</span>
<span class="sd">            :attr:`ds` attribute are used.</span>
<span class="sd">        axis: {&#39;x&#39;, &#39;y&#39;}</span>
<span class="sd">            The spatial axis to check</span>
<span class="sd">        nans: {None, &#39;skip&#39;, &#39;only&#39;}</span>
<span class="sd">            Determines whether values with nan shall be left (None), skipped</span>
<span class="sd">            (``&#39;skip&#39;``) or shall be the only one returned (``&#39;only&#39;``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray or None</span>
<span class="sd">            the bounds corrdinate (if existent)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">get_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_x</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coord_cell_node_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">nans</span><span class="p">,</span>
                                                     <span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plotbounds</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dim0</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">dim0</span><span class="p">,</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">),</span>  <span class="n">attrs</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;2D bounds are not yet sufficiently tested!&quot;</span><span class="p">)</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                   <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                   <span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                   <span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">),</span>
                        <span class="n">attrs</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;More than 2D-bounds are not supported&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># normal CF-Conventions for rectangular grids</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">values</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]]</span>
                    <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                            <span class="n">stacked</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_x</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stacked</span> <span class="o">=</span> <span class="n">stacked</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
                            <span class="n">stacked</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stacked</span> <span class="o">=</span> <span class="n">stacked</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">stacked</span><span class="p">,</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">attrs</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">bounds</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span><span class="s1">&#39;CFDecoder.get_cell_node_coord.parameters&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_get_coord_cell_node_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">var</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the boundaries of an unstructed coordinate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord: xr.Variable</span>
<span class="sd">            The coordinate whose bounds should be returned</span>
<span class="sd">        %(CFDecoder.get_cell_node_coord.parameters.no_var|axis)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_cell_node_coord.returns)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
                    <span class="n">key</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">dims</span><span class="p">)})</span>
            <span class="k">if</span> <span class="n">nans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need the variable to deal with NaN!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">nans</span> <span class="o">==</span> <span class="s1">&#39;skip&#39;</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">dims</span><span class="p">)]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span> <span class="k">if</span> <span class="n">dims</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># 3D bounds</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nans</span> <span class="o">==</span> <span class="s1">&#39;only&#39;</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">dims</span><span class="p">)]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span> <span class="k">if</span> <span class="n">dims</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`nans` must be either None, &#39;skip&#39;, or &#39;only&#39;! &quot;</span>
                    <span class="s2">&quot;Not </span><span class="si">{0}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nans</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">bounds</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder._check_unstructured_bounds&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_check_unstructured_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the bounds in the variable attribute are triangular</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.get_cell_node_coord.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or None</span>
<span class="sd">            True, if unstructered, None if it could not be determined</span>
<span class="sd">        xarray.Coordinate or None</span>
<span class="sd">            the bounds corrdinate (if existent)&quot;&quot;&quot;</span>
        <span class="c1"># !!! WILL BE REMOVED IN THE NEAR FUTURE! !!!</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_node_coord</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="n">nans</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

<div class="viewcode-block" id="CFDecoder.is_unstructured"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.is_unstructured">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">is_unstructured</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if a variable is on an unstructered grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.is_unstructured.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.is_unstructured.returns)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently this is the same as :meth:`is_unstructured` method, but may</span>
<span class="sd">        change in the future to support hexagonal grids&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid_type&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;unstructured&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_x</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xcoord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coord_cell_node_coord</span><span class="p">(</span><span class="n">xcoord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="CFDecoder.is_circumpolar"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.is_circumpolar">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">is_circumpolar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if a variable is on a circumpolar grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.is_unstructured.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.is_unstructured.returns)s&quot;&quot;&quot;</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_x</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xcoord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="CFDecoder.get_variable_by_axis"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_variable_by_axis">[docs]</a>    <span class="k">def</span> <span class="nf">get_variable_by_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinate matching the specified axis</span>

<span class="sd">        This method uses to ``&#39;axis&#39;`` attribute in coordinates to return the</span>
<span class="sd">        corresponding coordinate of the given variable</span>

<span class="sd">        Possible types</span>
<span class="sd">        --------------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to get the dimension for</span>
<span class="sd">        axis: {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;t&#39;}</span>
<span class="sd">            The axis string that identifies the dimension</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Coordinates to use. If None, the coordinates of the dataset in the</span>
<span class="sd">            :attr:`ds` attribute are used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Coordinate or None</span>
<span class="sd">            The coordinate for `var` that matches the given `axis` or None if</span>
<span class="sd">            no coordinate with the right `axis` could be found.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a rather low-level function that only interpretes the</span>
<span class="sd">        CFConvention. It is used by the :meth:`get_x`,</span>
<span class="sd">        :meth:`get_y`, :meth:`get_z` and :meth:`get_t` methods</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        If None of the coordinates have an ``&#39;axis&#39;`` attribute, we use the</span>
<span class="sd">        ``&#39;coordinate&#39;`` attribute of `var` (if existent).</span>
<span class="sd">        Since however the CF Conventions do not determine the order on how</span>
<span class="sd">        the coordinates shall be saved, we try to use a pattern matching</span>
<span class="sd">        for latitude (``&#39;lat&#39;``) and longitude (``lon&#39;``). If this patterns</span>
<span class="sd">        do not match, we interpret the  coordinates such that x: -1, y: -2,</span>
<span class="sd">        z: -3. This is all not very safe for awkward dimension names,</span>
<span class="sd">        but works for most cases. If you want to be a hundred percent sure,</span>
<span class="sd">        use the :attr:`x`, :attr:`y`, :attr:`z` and :attr:`t` attribute.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_x, get_y, get_z, get_t&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span><span class="n">cname</span><span class="p">,</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coords</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">raise_error</span><span class="p">:</span>
                        <span class="k">raise</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">idims</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">idims</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># got xarray.Variable</span>
                    <span class="n">idims</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">sl</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">idims</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                   <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">dims</span><span class="p">})</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;xyzt&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axis must be one of X, Y, Z, T, not </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">axis</span><span class="p">))</span>
        <span class="c1"># we first check for the dimensions and then for the coordinates</span>
        <span class="c1"># attribute</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coord_names</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">matched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">dim</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">dim</span><span class="p">:</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">,</span> <span class="n">chain</span><span class="p">(</span>
                    <span class="n">coord_names</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">))):</span>
            <span class="c1"># check for the axis attribute or whether the coordinate is in the</span>
            <span class="c1"># list of possible coordinate names</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
                    <span class="n">matched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matched</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">matched</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for </span><span class="si">%s</span><span class="s2"> coordinate in the &quot;</span>
                     <span class="s2">&quot;coordinates: </span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                         <span class="n">axis</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">matched</span><span class="p">]),</span>
                         <span class="n">matched</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">matched</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If the coordinates attribute is specified but the coordinate</span>
        <span class="c1"># variables themselves have no &#39;axis&#39; attribute, we interpret the</span>
        <span class="c1"># coordinates such that x: -1, y: -2, z: -3</span>
        <span class="c1"># Since however the CF Conventions do not determine the order on how</span>
        <span class="c1"># the coordinates shall be saved, we try to use a pattern matching</span>
        <span class="c1"># for latitude and longitude. This is not very nice, hence it is</span>
        <span class="c1"># better to specify the :attr:`x` and :attr:`y` attribute</span>
        <span class="n">tnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cname</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">cname</span><span class="p">),</span>
                                <span class="n">coord_names</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">coord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cname</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cname</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">cname</span><span class="p">),</span>
                                <span class="n">coord_names</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">coord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span>
              <span class="n">coord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tnames</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">coord_names</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span> <span class="ow">and</span> <span class="n">tnames</span><span class="p">:</span>
            <span class="n">tname</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">tnames</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tnames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for time coordinate in the &quot;</span>
                     <span class="s2">&quot;coordinates: </span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tnames</span><span class="p">),</span> <span class="n">tname</span><span class="p">),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_coord</span><span class="p">(</span><span class="n">tname</span><span class="p">,</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFDecoder.get_x"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_x">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s2">&quot;CFDecoder.get_x&quot;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">get_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the x-coordinate of a variable</span>

<span class="sd">        This method searches for the x-coordinate in the :attr:`ds`. It first</span>
<span class="sd">        checks whether there is one dimension that holds an ``&#39;axis&#39;``</span>
<span class="sd">        attribute with &#39;X&#39;, otherwise it looks whether there is an intersection</span>
<span class="sd">        between the :attr:`x` attribute and the variables dimensions, otherwise</span>
<span class="sd">        it returns the coordinate corresponding to the last dimension of `var`</span>

<span class="sd">        Possible types</span>
<span class="sd">        --------------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to get the x-coordinate for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Coordinates to use. If None, the coordinates of the dataset in the</span>
<span class="sd">            :attr:`ds` attribute are used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Coordinate or None</span>
<span class="sd">            The y-coordinate or None if it could be found&quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coord</span>
        <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xname</span><span class="p">(</span><span class="n">var</span><span class="p">))</span></div>

<div class="viewcode-block" id="CFDecoder.get_xname"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_xname">[docs]</a>    <span class="k">def</span> <span class="nf">get_xname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the x-dimension</span>

<span class="sd">        This method gives the name of the x-dimension (which is not necessarily</span>
<span class="sd">        the name of the coordinate if the variable has a coordinate attribute)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variables</span>
<span class="sd">            The variable to get the dimension for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            The coordinates to use for checking the axis attribute. If None,</span>
<span class="sd">            they are not used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The coordinate name</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_x&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dimlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dimlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for x coordinate in the variable:&quot;</span>
                     <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dimlist</span><span class="p">),</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise we return the coordinate in the last position</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="CFDecoder.get_y"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_y">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s2">&quot;CFDecoder.get_y&quot;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">get_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the y-coordinate of a variable</span>

<span class="sd">        This method searches for the y-coordinate in the :attr:`ds`. It first</span>
<span class="sd">        checks whether there is one dimension that holds an ``&#39;axis&#39;``</span>
<span class="sd">        attribute with &#39;Y&#39;, otherwise it looks whether there is an intersection</span>
<span class="sd">        between the :attr:`y` attribute and the variables dimensions, otherwise</span>
<span class="sd">        it returns the coordinate corresponding to the second last dimension of</span>
<span class="sd">        `var` (or the last if the dimension of var is one-dimensional)</span>

<span class="sd">        Possible types</span>
<span class="sd">        --------------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to get the y-coordinate for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Coordinates to use. If None, the coordinates of the dataset in the</span>
<span class="sd">            :attr:`ds` attribute are used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Coordinate or None</span>
<span class="sd">            The y-coordinate or None if it could be found&quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coord</span>
        <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_yname</span><span class="p">(</span><span class="n">var</span><span class="p">))</span></div>

<div class="viewcode-block" id="CFDecoder.get_yname"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_yname">[docs]</a>    <span class="k">def</span> <span class="nf">get_yname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the y-dimension</span>

<span class="sd">        This method gives the name of the y-dimension (which is not necessarily</span>
<span class="sd">        the name of the coordinate if the variable has a coordinate attribute)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variables</span>
<span class="sd">            The variable to get the dimension for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            The coordinates to use for checking the axis attribute. If None,</span>
<span class="sd">            they are not used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The coordinate name</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_y&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dimlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dimlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for y coordinate in the variable:&quot;</span>
                     <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dimlist</span><span class="p">),</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise we return the coordinate in the last or second last</span>
        <span class="c1"># position</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unstructured</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="CFDecoder.get_z"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_z">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s2">&quot;CFDecoder.get_z&quot;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">get_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the vertical (z-) coordinate of a variable</span>

<span class="sd">        This method searches for the z-coordinate in the :attr:`ds`. It first</span>
<span class="sd">        checks whether there is one dimension that holds an ``&#39;axis&#39;``</span>
<span class="sd">        attribute with &#39;Z&#39;, otherwise it looks whether there is an intersection</span>
<span class="sd">        between the :attr:`z` attribute and the variables dimensions, otherwise</span>
<span class="sd">        it returns the coordinate corresponding to the third last dimension of</span>
<span class="sd">        `var` (or the second last or last if var is two or one-dimensional)</span>

<span class="sd">        Possible types</span>
<span class="sd">        --------------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to get the z-coordinate for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Coordinates to use. If None, the coordinates of the dataset in the</span>
<span class="sd">            :attr:`ds` attribute are used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Coordinate or None</span>
<span class="sd">            The z-coordinate or None if no z coordinate could be found&quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coord</span>
        <span class="n">zname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_zname</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">zname</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CFDecoder.get_zname"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_zname">[docs]</a>    <span class="k">def</span> <span class="nf">get_zname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the z-dimension</span>

<span class="sd">        This method gives the name of the z-dimension (which is not necessarily</span>
<span class="sd">        the name of the coordinate if the variable has a coordinate attribute)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variables</span>
<span class="sd">            The variable to get the dimension for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            The coordinates to use for checking the axis attribute. If None,</span>
<span class="sd">            they are not used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">            The coordinate name or None if no vertical coordinate could be</span>
<span class="sd">            found</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_z&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dimlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dimlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for z coordinate in the variable:&quot;</span>
                     <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dimlist</span><span class="p">),</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise we return the coordinate in the third last position</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="n">is_unstructured</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unstructured</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">icheck</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="k">if</span> <span class="n">is_unstructured</span> <span class="k">else</span> <span class="o">-</span><span class="mi">3</span>
            <span class="n">min_dim</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">icheck</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;variable&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="k">else</span> <span class="nb">abs</span><span class="p">(</span><span class="n">icheck</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="n">min_dim</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">icheck</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tname</span><span class="p">(</span>
                    <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">icheck</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CFDecoder.get_t"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_t">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s2">&quot;CFDecoder.get_t&quot;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">get_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the time coordinate of a variable</span>

<span class="sd">        This method searches for the time coordinate in the :attr:`ds`. It</span>
<span class="sd">        first checks whether there is one dimension that holds an ``&#39;axis&#39;``</span>
<span class="sd">        attribute with &#39;T&#39;, otherwise it looks whether there is an intersection</span>
<span class="sd">        between the :attr:`t` attribute and the variables dimensions, otherwise</span>
<span class="sd">        it returns the coordinate corresponding to the first dimension of `var`</span>

<span class="sd">        Possible types</span>
<span class="sd">        --------------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to get the time coordinate for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Coordinates to use. If None, the coordinates of the dataset in the</span>
<span class="sd">            :attr:`ds` attribute are used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Coordinate or None</span>
<span class="sd">            The time coordinate or None if no time coordinate could be found&quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coord</span>
        <span class="n">dimlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dimlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for time coordinate in the &quot;</span>
                     <span class="s2">&quot;variable: </span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                         <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dimlist</span><span class="p">),</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coords</span><span class="p">[</span><span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">tname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tname</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tname</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CFDecoder.get_tname"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_tname">[docs]</a>    <span class="k">def</span> <span class="nf">get_tname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the t-dimension</span>

<span class="sd">        This method gives the name of the time dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variables</span>
<span class="sd">            The variable to get the dimension for</span>
<span class="sd">        coords: dict</span>
<span class="sd">            The coordinates to use for checking the axis attribute. If None,</span>
<span class="sd">            they are not used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or None</span>
<span class="sd">            The coordinate name or None if no time coordinate could be found</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_t&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable_by_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span>
        <span class="n">dimlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dimlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found multiple matches for t coordinate in the variable:&quot;</span>
                     <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">. I use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dimlist</span><span class="p">),</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                     <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dimlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise we return None</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CFDecoder.get_idims"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_idims">[docs]</a>    <span class="k">def</span> <span class="nf">get_idims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the coordinates in the :attr:`ds` dataset as int or slice</span>

<span class="sd">        This method returns a mapping from the coordinate names of the given</span>
<span class="sd">        `arr` to an integer, slice or an array of integer that represent the</span>
<span class="sd">        coordinates in the :attr:`ds` dataset and can be used to extract the</span>
<span class="sd">        given `arr` via the :meth:`xarray.Dataset.isel` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr: xarray.DataArray</span>
<span class="sd">            The data array for which to get the dimensions as integers, slices</span>
<span class="sd">            or list of integers from the dataset in the :attr:`base` attribute</span>
<span class="sd">        coords: iterable</span>
<span class="sd">            The coordinates to use. If not given all coordinates in the</span>
<span class="sd">            ``arr.coords`` attribute are used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Mapping from coordinate name to integer, list of integer or slice</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        xarray.Dataset.isel, InteractiveArray.idims&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">coord</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord_idims</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="c1"># handle the coordinates that are not in the dataset</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not get slices for the following dimensions: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">missing</span><span class="p">,</span> <span class="p">),</span> <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="CFDecoder.get_coord_idims"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_coord_idims">[docs]</a>    <span class="k">def</span> <span class="nf">get_coord_idims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the slicers for the given coordinates from the base dataset</span>

<span class="sd">        This method converts `coords` to slicers (list of</span>
<span class="sd">        integers or ``slice`` objects)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords: dict</span>
<span class="sd">            A subset of the ``ds.coords`` attribute of the base dataset</span>
<span class="sd">            :attr:`ds`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Mapping from coordinate name to integer, list of integer or slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">get_index_from_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">label</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">indexes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="CFDecoder.get_plotbounds"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_plotbounds">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder.get_plotbounds&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">get_plotbounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the bounds of a coordinate</span>

<span class="sd">        This method first checks the ``&#39;bounds&#39;`` attribute of the given</span>
<span class="sd">        `coord` and if it fails, it calculates them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord: xarray.Coordinate</span>
<span class="sd">            The coordinate to get the bounds for</span>
<span class="sd">        kind: str</span>
<span class="sd">            The interpolation method (see :func:`scipy.interpolate.interp1d`)</span>
<span class="sd">            that is used in case of a 2-dimensional coordinate</span>
<span class="sd">        ignore_shape: bool</span>
<span class="sd">            If True and the `coord` has a ``&#39;bounds&#39;`` attribute, this</span>
<span class="sd">            attribute is returned without further check. Otherwise it is tried</span>
<span class="sd">            to bring the ``&#39;bounds&#39;`` into a format suitable for (e.g.) the</span>
<span class="sd">            :func:`matplotlib.pyplot.pcolormesh` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bounds: np.ndarray</span>
<span class="sd">            The bounds with the same number of dimensions as `coord` but one</span>
<span class="sd">            additional array (i.e. if `coord` has shape (4, ), `bounds` will</span>
<span class="sd">            have shape (5, ) and if `coord` has shape (4, 5), `bounds` will</span>
<span class="sd">            have shape (5, 6)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;bounds&#39;</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ignore_shape</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bounds</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_idims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotbounds_from_cf</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">((</span><span class="n">e</span><span class="o">.</span><span class="n">message</span> <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="o">+</span>
                     <span class="s2">&quot; Bounds are calculated automatically!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_interval_breaks</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_get_plotbounds_from_cf</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get plot bounds from the bounds stored as defined by CFConventions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord: xarray.Coordinate</span>
<span class="sd">            The coordinate to get the bounds for</span>
<span class="sd">        bounds: xarray.DataArray</span>
<span class="sd">            The bounds as inferred from the attributes of the given `coord`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_plotbounds.returns)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        this currently only works for rectilinear grids&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot interprete bounds with shape </span><span class="si">{0}</span><span class="s2"> for </span><span class="si">{1}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;coordinate with shape </span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">ret</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">last_slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">last_slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">last_slices</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;CFDecoder._check_unstructured_bounds.parameters&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;nans&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="CFDecoder.get_triangles"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.get_triangles">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder.get_triangles&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert_radian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">src_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">nans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the triangles for the variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variable or xarray.DataArray</span>
<span class="sd">            The variable to use</span>
<span class="sd">        coords: dict</span>
<span class="sd">            Alternative coordinates to use. If None, the coordinates of the</span>
<span class="sd">            :attr:`ds` dataset are used</span>
<span class="sd">        convert_radian: bool</span>
<span class="sd">            If True and the coordinate has units in &#39;radian&#39;, those are</span>
<span class="sd">            converted to degrees</span>
<span class="sd">        copy: bool</span>
<span class="sd">            If True, vertice arrays are copied</span>
<span class="sd">        src_crs: cartopy.crs.Crs</span>
<span class="sd">            The source projection of the data. If not None, a transformation</span>
<span class="sd">            to the given `target_crs` will be done</span>
<span class="sd">        target_crs: cartopy.crs.Crs</span>
<span class="sd">            The target projection for which the triangles shall be transformed.</span>
<span class="sd">            Must only be provided if the `src_crs` is not None.</span>
<span class="sd">        %(CFDecoder._check_unstructured_bounds.parameters.nans)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.tri.Triangulation</span>
<span class="sd">            The spatial triangles of the variable</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `src_crs` is not None and `target_crs` is None&quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The &#39;get_triangles&#39; method is depreceated and will be removed &quot;</span>
             <span class="s2">&quot;soon! Use the &#39;get_cell_node_coord&#39; method!&quot;</span><span class="p">,</span>
             <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.tri</span> <span class="kn">import</span> <span class="n">Triangulation</span>

        <span class="k">def</span> <span class="nf">get_vertices</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_unstructured_bounds</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                                                   <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="n">nans</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">convert_radian</span><span class="p">:</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get_&#39;</span> <span class="o">+</span> <span class="n">axis</span><span class="p">)(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;radian&#39;</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">return</span> <span class="n">vertices</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>

        <span class="n">xvert</span> <span class="o">=</span> <span class="n">get_vertices</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">yvert</span> <span class="o">=</span> <span class="n">get_vertices</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">src_crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">src_crs</span> <span class="o">!=</span> <span class="n">target_crs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target_crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2"> for the source crs but got None for the &quot;</span>
                    <span class="s2">&quot;target_crs!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">src_crs</span><span class="p">,</span> <span class="p">))</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">target_crs</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">src_crs</span><span class="p">,</span> <span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span><span class="p">)</span>
            <span class="n">xvert</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">yvert</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvert</span><span class="p">)),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvert</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Triangulation</span><span class="p">(</span><span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span>
        <span class="s1">&#39;CFDecoder.get_plotbounds.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore_shape&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_infer_interval_breaks</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate the bounds from the data in coord</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.get_plotbounds.parameters.no_ignore_shape)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_plotbounds.returns)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        this currently only works for rectilinear grids&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_infer_interval_breaks</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp2d</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span> <span class="ow">or</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;decoder.interp_kind&#39;</span><span class="p">]</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_infer_interval_breaks</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">interp2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;CFDecoder._decode_ds&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_decode_ds</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">decode_times</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Static method to decode coordinates and time informations</span>

<span class="sd">        This method interpretes absolute time informations (stored with units</span>
<span class="sd">        ``&#39;day as %Y%m%d.%f&#39;``) and coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.decode_coords.parameters)s</span>
<span class="sd">        decode_times : bool, optional</span>
<span class="sd">            If True, decode times encoded in the standard NetCDF datetime</span>
<span class="sd">            format into datetime objects. Otherwise, leave them encoded as</span>
<span class="sd">            numbers.</span>
<span class="sd">        decode_coords : bool, optional</span>
<span class="sd">            If True, decode the &#39;coordinates&#39; attribute to identify coordinates</span>
<span class="sd">            in the resulting dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">decode_coords</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">decode_coords</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="n">gridfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">decode_times</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
                <span class="c1"># check for absolute time units and make sure the data is not</span>
                <span class="c1"># already decoded via dtype check</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;day as %Y%m</span><span class="si">%d</span><span class="s1">.</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
                    <span class="n">decoded</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">AbsoluteTimeDecoder</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">attrs</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                        <span class="n">encoding</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">decoded</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ds</span>

<div class="viewcode-block" id="CFDecoder.decode_ds"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.decode_ds">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">decode_ds</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Static method to decode coordinates and time informations</span>

<span class="sd">        This method interpretes absolute time informations (stored with units</span>
<span class="sd">        ``&#39;day as %Y%m%d.%f&#39;``) and coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder._decode_ds.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Dataset</span>
<span class="sd">            The decoded dataset&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">decoder_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_registry</span> <span class="o">+</span> <span class="p">[</span><span class="n">CFDecoder</span><span class="p">]:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">decoder_cls</span><span class="o">.</span><span class="n">_decode_ds</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span></div>

<div class="viewcode-block" id="CFDecoder.correct_dims"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.correct_dims">[docs]</a>    <span class="k">def</span> <span class="nf">correct_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="n">remove</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands the dimensions to match the dims in the variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to get the data for</span>
<span class="sd">        dims: dict</span>
<span class="sd">            a mapping from dimension to the slices</span>
<span class="sd">        remove: bool</span>
<span class="sd">            If True, dimensions in `dims` that are not in the dimensions of</span>
<span class="sd">            `var` are removed&quot;&quot;&quot;</span>
        <span class="n">method_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xname</span><span class="p">,</span>
                          <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_zname</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tname</span><span class="p">}</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unstructured</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>  <span class="c1"># we assume a one-dimensional grid</span>
            <span class="n">method_mapping</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method_mapping</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yname</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">method_mapping</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">dim_name</span> <span class="o">=</span> <span class="n">method_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                    <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">method_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">var</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dims</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># now remove the unnecessary dimensions</span>
        <span class="k">if</span> <span class="n">remove</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find a dimensions matching </span><span class="si">%s</span><span class="s2"> in variable </span><span class="si">%s</span><span class="s2">!&quot;</span><span class="p">,</span>
                    <span class="n">key</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dims</span></div>

<div class="viewcode-block" id="CFDecoder.standardize_dims"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.CFDecoder.standardize_dims">[docs]</a>    <span class="k">def</span> <span class="nf">standardize_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Replace the coordinate names through x, y, z and t</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The variable to use the dimensions of</span>
<span class="sd">        dims: dict</span>
<span class="sd">            The dictionary to use for replacing the original dimensions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The dictionary with replaced dimensions&quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">name_map</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xname</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_yname</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_zname</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_tname</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span> <span class="s1">&#39;t&#39;</span><span class="p">}</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">name_map</span><span class="p">):</span>
            <span class="n">dims</span><span class="p">[</span><span class="n">name_map</span><span class="p">[</span><span class="n">dim</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dims</span></div></div>


<div class="viewcode-block" id="UGridDecoder"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder">[docs]</a><span class="k">class</span> <span class="nc">UGridDecoder</span><span class="p">(</span><span class="n">CFDecoder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decoder for UGrid data sets</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    Currently only triangles are supported.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="UGridDecoder.is_unstructured"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.is_unstructured">[docs]</a>    <span class="k">def</span> <span class="nf">is_unstructured</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reimpletemented to return always True. Any ``*args`` and ``**kwargs``</span>
<span class="sd">        are ignored&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="UGridDecoder.get_mesh"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.get_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the mesh variable for the given `var`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var: xarray.Variable</span>
<span class="sd">            The data source whith the ``&#39;mesh&#39;`` attribute</span>
<span class="sd">        coords: dict</span>
<span class="sd">            The coordinates to use. If None, the coordinates of the dataset of</span>
<span class="sd">            this decoder is used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.Coordinate</span>
<span class="sd">            The mesh coordinate&quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span></div>

<div class="viewcode-block" id="UGridDecoder.can_decode"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.can_decode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">can_decode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the given variable can be decoded.</span>

<span class="sd">        Returns True if a mesh coordinate could be found via the</span>
<span class="sd">        :meth:`get_mesh` method</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.can_decode.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.can_decode.returns)s&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="UGridDecoder.get_triangles"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.get_triangles">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert_radian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">src_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the of the given coordinate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.get_triangles.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_triangles.returns)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the ``&#39;location&#39;`` attribute is set to ``&#39;node&#39;``, a delaunay</span>
<span class="sd">        triangulation is performed using the</span>
<span class="sd">        :class:`matplotlib.tri.Triangulation` class.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Implement the visualization for UGrid data shown on the edge of the</span>
<span class="sd">            triangles&quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The &#39;get_triangles&#39; method is depreceated and will be removed &quot;</span>
             <span class="s2">&quot;soon! Use the &#39;get_cell_node_coord&#39; method!&quot;</span><span class="p">,</span>
             <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.tri</span> <span class="kn">import</span> <span class="n">Triangulation</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>

        <span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find the nodes variables!&quot;</span><span class="p">)</span>
        <span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="n">xvert</span> <span class="o">=</span> <span class="n">xvert</span><span class="o">.</span><span class="n">values</span>
        <span class="n">yvert</span> <span class="o">=</span> <span class="n">yvert</span><span class="o">.</span><span class="n">values</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s1">&#39;face&#39;</span><span class="p">:</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="n">get_coord</span><span class="p">(</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;face_node_connectivity&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">triangles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the connectivity information!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not interprete location attribute (</span><span class="si">%s</span><span class="s2">) of mesh &quot;</span>
                <span class="s2">&quot;variable </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">convert_radian</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;radian&#39;</span><span class="p">:</span>
                    <span class="n">coord</span> <span class="o">=</span> <span class="n">coord</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="n">src_crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">src_crs</span> <span class="o">!=</span> <span class="n">target_crs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target_crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2"> for the source crs but got None for the &quot;</span>
                    <span class="s2">&quot;target_crs!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">src_crs</span><span class="p">,</span> <span class="p">))</span>
            <span class="n">xvert</span> <span class="o">=</span> <span class="n">xvert</span><span class="p">[</span><span class="n">triangles</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">yvert</span> <span class="o">=</span> <span class="n">yvert</span><span class="p">[</span><span class="n">triangles</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">target_crs</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">src_crs</span><span class="p">,</span> <span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span><span class="p">)</span>
            <span class="n">xvert</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">yvert</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s1">&#39;face&#39;</span><span class="p">:</span>
                <span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvert</span><span class="p">)),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvert</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">,</span>
                                                           <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Triangulation</span><span class="p">(</span><span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span></div>

<div class="viewcode-block" id="UGridDecoder.get_cell_node_coord"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.get_cell_node_coord">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_cell_node_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">nans</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the bounds in the variable attribute are triangular</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.get_cell_node_coord.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_cell_node_coord.returns)s&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>

        <span class="n">idims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord_idims</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">sl</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">idims</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                 <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">})</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find the nodes variables for the </span><span class="si">%s</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;coordinate!&quot;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">vert</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find the nodes variables for the </span><span class="si">%s</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;coordinate!&quot;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span>
            <span class="c1"># we assume a triangular grid and use matplotlibs triangulation</span>
            <span class="kn">from</span> <span class="nn">matplotlib.tri</span> <span class="kn">import</span> <span class="n">Triangulation</span>
            <span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span> <span class="o">=</span> <span class="n">nodes</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="n">xvert</span><span class="p">,</span> <span class="n">yvert</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">triangles</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">triangles</span><span class="o">.</span><span class="n">triangles</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">triangles</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">triangles</span><span class="o">.</span><span class="n">triangles</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">]:</span>
            <span class="n">connectivity</span> <span class="o">=</span> <span class="n">get_coord</span><span class="p">(</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_node_connectivity&#39;</span> <span class="o">%</span> <span class="n">loc</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the connectivity information!&quot;</span><span class="p">)</span>
            <span class="n">connectivity</span> <span class="o">=</span> <span class="n">connectivity</span><span class="o">.</span><span class="n">values</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">vert</span><span class="o">.</span><span class="n">values</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">connectivity</span><span class="p">),</span> <span class="n">connectivity</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not interprete location attribute (</span><span class="si">%s</span><span class="s2">) of mesh &quot;</span>
                <span class="s2">&quot;variable </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">dim0</span> <span class="o">=</span> <span class="s1">&#39;__face&#39;</span> <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">bounds</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dim0</span><span class="p">,</span> <span class="p">)</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">dims</span><span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">dim0</span><span class="p">,</span> <span class="s1">&#39;__bnds&#39;</span><span class="p">,</span> <span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="n">vert</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">,</span>  <span class="n">attrs</span><span class="o">=</span><span class="n">vert</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="UGridDecoder.decode_coords"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.decode_coords">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">decode_coords</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reimplemented to set the mesh variables as coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.decode_coords.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.decode_coords.returns)s&quot;&quot;&quot;</span>
        <span class="n">extra_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mesh&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">mesh</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extra_coords</span><span class="p">:</span>
                    <span class="n">extra_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">mesh_var</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">mesh</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not find mesh variable </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesh</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="s1">&#39;node_coordinates&#39;</span> <span class="ow">in</span> <span class="n">mesh_var</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                        <span class="n">extra_coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                            <span class="n">mesh_var</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;node_coordinates&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
                    <span class="k">if</span> <span class="s1">&#39;face_node_connectivity&#39;</span> <span class="ow">in</span> <span class="n">mesh_var</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                        <span class="n">extra_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                            <span class="n">mesh_var</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;face_node_connectivity&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">gridfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gridfile</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">gridfile</span> <span class="o">=</span> <span class="n">open_dataset</span><span class="p">(</span><span class="n">gridfile</span><span class="p">)</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">gridfile</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
                       <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_coords</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">xr_version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">set_coords</span><span class="p">(</span><span class="n">extra_coords</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span>
                          <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">_coord_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">extra_coords</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ds</span></div>

<div class="viewcode-block" id="UGridDecoder.get_nodes"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.get_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the variables containing the definition of the nodes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord: xarray.Coordinate</span>
<span class="sd">            The mesh variable</span>
<span class="sd">        coords: dict</span>
<span class="sd">            The coordinates to use to get node coordinates&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_coord</span><span class="p">,</span>
                        <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_coordinates&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]))</span></div>

<div class="viewcode-block" id="UGridDecoder.get_x"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.get_x">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the centers of the triangles in the x-dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.get_y.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_y.returns)s&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="c1"># first we try the super class</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">UGridDecoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_x</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="c1"># but if that doesn&#39;t work because we get the variable name in the</span>
        <span class="c1"># dimension of `var`, we use the means of the triangles</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ret</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;mesh&#39;</span><span class="p">)</span> <span class="ow">and</span>
                                                   <span class="n">ret</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_node_coord</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">centers</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">),</span> <span class="n">coords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">cls</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">IndexVariable</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># xarray &lt; 0.9</span>
                    <span class="bp">cls</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Coordinate</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="UGridDecoder.get_y"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.UGridDecoder.get_y">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the centers of the triangles in the y-dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(CFDecoder.get_y.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(CFDecoder.get_y.returns)s&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span>
        <span class="c1"># first we try the super class</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">UGridDecoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="c1"># but if that doesn&#39;t work because we get the variable name in the</span>
        <span class="c1"># dimension of `var`, we use the means of the triangles</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ret</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">dims</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;mesh&#39;</span><span class="p">)</span> <span class="ow">and</span>
                                                   <span class="n">ret</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_node_coord</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">centers</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">coords</span><span class="p">),</span> <span class="n">coords</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">cls</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">IndexVariable</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># xarray &lt; 0.9</span>
                    <span class="bp">cls</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Coordinate</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div></div>


<span class="c1"># register the UGridDecoder</span>
<span class="n">CFDecoder</span><span class="o">.</span><span class="n">register_decoder</span><span class="p">(</span><span class="n">UGridDecoder</span><span class="p">)</span>

<span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;CFDecoder.decode_coords.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;gridfile&#39;</span><span class="p">)</span>
<span class="n">docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span>
    <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
    <span class="s1">&#39;xarray.open_dataset&#39;</span><span class="p">)</span>
<span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span><span class="s1">&#39;xarray.open_dataset.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;engine&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="open_dataset"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.open_dataset">[docs]</a><span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;open_dataset&#39;</span><span class="p">)</span>
<span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
<span class="k">def</span> <span class="nf">open_dataset</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">decode_times</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">decode_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Open an instance of :class:`xarray.Dataset`.</span>

<span class="sd">    This method has the same functionality as the :func:`xarray.open_dataset`</span>
<span class="sd">    method except that is supports an additional &#39;gdal&#39; engine to open</span>
<span class="sd">    gdal Rasters (e.g. GeoTiffs) and that is supports absolute time units like</span>
<span class="sd">    ``&#39;day as %Y%m%d.%f&#39;`` (if `decode_cf` and `decode_times` are True).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(xarray.open_dataset.parameters.no_engine)s</span>
<span class="sd">    engine: {&#39;netcdf4&#39;, &#39;scipy&#39;, &#39;pydap&#39;, &#39;h5netcdf&#39;, &#39;gdal&#39;}, optional</span>
<span class="sd">        Engine to use when reading netCDF files. If not provided, the default</span>
<span class="sd">        engine is chosen based on available dependencies, with a preference for</span>
<span class="sd">        &#39;netcdf4&#39;.</span>
<span class="sd">    %(CFDecoder.decode_coords.parameters.gridfile)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xarray.Dataset</span>
<span class="sd">        The dataset that contains the variables from `filename_or_obj`&quot;&quot;&quot;</span>
    <span class="c1"># use the absolute path name (is saver when saving the project)</span>
    <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">osp</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">):</span>
        <span class="n">filename_or_obj</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="s1">&#39;gdal&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">psyplot.gdal_store</span> <span class="kn">import</span> <span class="n">GdalStore</span>
        <span class="n">filename_or_obj</span> <span class="o">=</span> <span class="n">GdalStore</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">)</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="n">decode_cf</span><span class="p">,</span>
                         <span class="n">decode_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
                         <span class="n">decode_times</span><span class="o">=</span><span class="n">decode_times</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">filename_or_obj</span><span class="p">):</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename_or_obj</span>
    <span class="k">if</span> <span class="n">decode_cf</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">CFDecoder</span><span class="o">.</span><span class="n">decode_ds</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">,</span> <span class="n">decode_coords</span><span class="o">=</span><span class="n">decode_coords</span><span class="p">,</span> <span class="n">decode_times</span><span class="o">=</span><span class="n">decode_times</span><span class="p">,</span>
            <span class="n">gridfile</span><span class="o">=</span><span class="n">gridfile</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ds</span></div>


<span class="n">docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span>
    <span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
    <span class="s1">&#39;xarray.open_mfdataset&#39;</span><span class="p">)</span>
<span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span><span class="s1">&#39;xarray.open_mfdataset.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;engine&#39;</span><span class="p">)</span>
<span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;get_tdata.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;t_format&#39;</span><span class="p">)</span>

<span class="n">docstrings</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;xarray.open_mfdataset.parameters.no_engine&#39;</span><span class="p">]</span> <span class="o">=</span> \
    <span class="n">docstrings</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;xarray.open_mfdataset.parameters.no_engine&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="s1">&#39;**kwargs&#39;</span><span class="p">,</span> <span class="s1">&#39;``**kwargs``&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;path/to/my/files/*.nc&quot;&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;``&quot;path/to/my/files/*.nc&quot;``&#39;</span><span class="p">)</span>


<span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;open_dataset.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;engine&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="open_mfdataset"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.open_mfdataset">[docs]</a><span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
<span class="k">def</span> <span class="nf">open_mfdataset</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">decode_times</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">decode_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">t_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Open multiple files as a single dataset.</span>

<span class="sd">    This function is essentially the same as the :func:`xarray.open_mfdataset`</span>
<span class="sd">    function but (as the :func:`open_dataset`) supports additional decoding</span>
<span class="sd">    and the ``&#39;gdal&#39;`` engine.</span>
<span class="sd">    You can further specify the `t_format` parameter to get the time</span>
<span class="sd">    information from the files and use the results to concatenate the files</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(xarray.open_mfdataset.parameters.no_engine)s</span>
<span class="sd">    %(open_dataset.parameters.engine)s</span>
<span class="sd">    %(get_tdata.parameters.t_format)s</span>
<span class="sd">    %(CFDecoder.decode_coords.parameters.gridfile)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xarray.Dataset</span>
<span class="sd">        The dataset that contains the variables from `filename_or_obj`&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">t_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">engine</span> <span class="o">==</span> <span class="s1">&#39;gdal&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;no files to open&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">get_tdata</span><span class="p">(</span><span class="n">t_format</span><span class="p">,</span> <span class="n">paths</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;concat_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
        <span class="k">if</span> <span class="n">xr_version</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;combine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nested&#39;</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">isstring</span><span class="p">,</span> <span class="n">paths</span><span class="p">)):</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="s1">&#39;gdal&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">psyplot.gdal_store</span> <span class="kn">import</span> <span class="n">GdalStore</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">GdalStore</span><span class="p">,</span> <span class="n">paths</span><span class="p">))</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">xr_version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">18</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lock&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="p">(</span>
        <span class="n">paths</span><span class="p">,</span> <span class="n">decode_cf</span><span class="o">=</span><span class="n">decode_cf</span><span class="p">,</span> <span class="n">decode_times</span><span class="o">=</span><span class="n">decode_times</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">decode_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filenames</span>
    <span class="k">if</span> <span class="n">decode_cf</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">CFDecoder</span><span class="o">.</span><span class="n">decode_ds</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">gridfile</span><span class="o">=</span><span class="n">gridfile</span><span class="p">,</span>
                                 <span class="n">decode_coords</span><span class="o">=</span><span class="n">decode_coords</span><span class="p">,</span>
                                 <span class="n">decode_times</span><span class="o">=</span><span class="n">decode_times</span><span class="p">)</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_concat_dim</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concat_dim&#39;</span><span class="p">)</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_combine</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;combine&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
    <span class="k">return</span> <span class="n">ds</span></div>


<div class="viewcode-block" id="InteractiveBase"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveBase">[docs]</a><span class="k">class</span> <span class="nc">InteractiveBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for the communication of a data object with a suitable plotter</span>

<span class="sd">    This class serves as an interface for data objects (in particular as a</span>
<span class="sd">    base for :class:`InteractiveArray` and :class:`InteractiveList`) to</span>
<span class="sd">    communicate with the corresponding :class:`~psyplot.plotter.Plotter` in the</span>
<span class="sd">    :attr:`plotter` attribute&quot;&quot;&quot;</span>

    <span class="c1">#: The :class:`psyplot.project.DataArrayPlotter`</span>
    <span class="n">_plot</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plotter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`psyplot.plotter.Plotter` instance that makes the interactive</span>
<span class="sd">        plotting of the data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plotter</span>

    <span class="nd">@plotter</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">plotter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plotter</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@plotter</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">plotter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plotter</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">no_auto_update</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_no_auto_update_getter</span><span class="p">,</span>
                              <span class="n">doc</span><span class="o">=</span><span class="n">_no_auto_update_getter</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An object to visualize this data object</span>

<span class="sd">        To make a 2D-plot with the :mod:`psy-simple &lt;psy_simple.plugin&gt;`</span>
<span class="sd">        plugin, you can just type</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            plotter = da.psy.plot.plot2d()</span>

<span class="sd">        It will create a new :class:`psyplot.plotter.Plotter` instance with the</span>
<span class="sd">        extracted and visualized data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        psyplot.project.DataArrayPlotter: for the different plot methods&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">psyplot.project</span> <span class="k">as</span> <span class="nn">psy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="n">psy</span><span class="o">.</span><span class="n">DataArrayPlotter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span>

    <span class="nd">@no_auto_update</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">no_auto_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">no_auto_update</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`logging.Logger` of this instance&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing...&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>

    <span class="nd">@logger</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The matplotlib axes the plotter of this data object plots on&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">ax</span>

    <span class="nd">@ax</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Cannot set the axes because the plotter attribute is None!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">block_signals</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_temp_bool_prop</span><span class="p">(</span>
        <span class="s1">&#39;block_signals&#39;</span><span class="p">,</span> <span class="s2">&quot;Block the emitting of signals of this instance&quot;</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># -------------------------------- SIGNALS --------------------------------</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

    <span class="c1">#: :class:`Signal` to be emitted when the object has been updated</span>
    <span class="n">onupdate</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="s1">&#39;_onupdate&#39;</span><span class="p">)</span>
    <span class="n">_onupdate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_plotter</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_docstring</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveBase._njobs&#39;</span><span class="p">)</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">_njobs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of jobs taken from the queue during an update process</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of int</span>
<span class="sd">            The length of the list determines the number of neccessary queues,</span>
<span class="sd">            the numbers in the list determines the number of tasks per queue</span>
<span class="sd">            this instance fullfills during the update process&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">_njobs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">arr_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`str`. The internal name of the :class:`InteractiveBase`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arr_name</span>

    <span class="nd">@arr_name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">arr_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arr_name</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onupdate</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span>

    <span class="n">_arr_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_no_auto_update</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveBase&#39;</span><span class="p">)</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plotter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">arr_name</span><span class="o">=</span><span class="s1">&#39;arr0&#39;</span><span class="p">,</span> <span class="n">auto_update</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plotter: Plotter</span>
<span class="sd">            Default: None. Interactive plotter that makes the plot via</span>
<span class="sd">            formatoption keywords.</span>
<span class="sd">        arr_name: str</span>
<span class="sd">            Default: ``&#39;data&#39;``. unique string of the array</span>
<span class="sd">        auto_update: bool</span>
<span class="sd">            Default: None. A boolean indicating whether this list shall</span>
<span class="sd">            automatically update the contained arrays when calling the</span>
<span class="sd">            :meth:`update` method or not. See also the :attr:`no_auto_update`</span>
<span class="sd">            attribute. If None, the value from the ``&#39;lists.auto_update&#39;``</span>
<span class="sd">            key in the :attr:`psyplot.rcParams` dictionary is used.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="o">=</span> <span class="n">plotter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">=</span> <span class="n">arr_name</span>
        <span class="k">if</span> <span class="n">auto_update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">auto_update</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lists.auto_update&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">auto_update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replot</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_finish_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queues</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">queue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">safe_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_njobs</span><span class="p">),</span> <span class="n">safe_list</span><span class="p">(</span><span class="n">queues</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">queue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveBase._register_update&#39;</span><span class="p">)</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">_register_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register new formatoptions for updating</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        replot: bool</span>
<span class="sd">            Boolean that determines whether the data specific formatoptions</span>
<span class="sd">            shall be updated in any case or not. Note, if `dims` is not empty</span>
<span class="sd">            or any coordinate keyword is in ``**kwargs``, this will be set to</span>
<span class="sd">            True automatically</span>
<span class="sd">        fmt: dict</span>
<span class="sd">            Keys may be any valid formatoption of the formatoptions in the</span>
<span class="sd">            :attr:`plotter`</span>
<span class="sd">        force: str, list of str or bool</span>
<span class="sd">            If formatoption key (i.e. string) or list of formatoption keys,</span>
<span class="sd">            thery are definitely updated whether they changed or not.</span>
<span class="sd">            If True, all the given formatoptions in this call of the are</span>
<span class="sd">            :meth:`update` method are updated</span>
<span class="sd">        todefault: bool</span>
<span class="sd">            If True, all changed formatoptions (except the registered ones)</span>
<span class="sd">            are updated to their default value as stored in the</span>
<span class="sd">            :attr:`~psyplot.plotter.Plotter.rc` attribute</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        start_update&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replot</span> <span class="ow">or</span> <span class="n">replot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="n">replot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replot</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span>
                                          <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">)</span>

<div class="viewcode-block" id="InteractiveBase.start_update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveBase.start_update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveBase.start_update&#39;</span><span class="p">,</span>
                              <span class="n">sections</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conduct the formerly registered updates</span>

<span class="sd">        This method conducts the updates that have been registered via the</span>
<span class="sd">        :meth:`update` method. You can call this method if the</span>
<span class="sd">        :attr:`no_auto_update` attribute of this instance and the `auto_update`</span>
<span class="sd">        parameter in the :meth:`update` method has been set to False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        draw: bool or None</span>
<span class="sd">            Boolean to control whether the figure of this array shall be drawn</span>
<span class="sd">            at the end. If None, it defaults to the `&#39;auto_draw&#39;`` parameter</span>
<span class="sd">            in the :attr:`psyplot.rcParams` dictionary</span>
<span class="sd">        queues: list of :class:`Queue.Queue` instances</span>
<span class="sd">            The queues that are passed to the</span>
<span class="sd">            :meth:`psyplot.plotter.Plotter.start_update` method to ensure a</span>
<span class="sd">            thread-safe update. It can be None if only one single plotter is</span>
<span class="sd">            updated at the same time. The number of jobs that are taken from</span>
<span class="sd">            the queue is determined by the :meth:`_njobs` attribute. Note that</span>
<span class="sd">            there this parameter is automatically configured when updating</span>
<span class="sd">            from a :class:`~psyplot.project.Project`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            A boolean indicating whether a redrawing is necessary or not</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`no_auto_update`, update</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="n">queues</span><span class="p">)</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;InteractiveBase.start_update.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;draw&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="InteractiveBase.update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveBase.update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveBase.update&#39;</span><span class="p">,</span>
                              <span class="n">sections</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Notes&#39;</span><span class="p">])</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">auto_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the coordinates and the plot</span>

<span class="sd">        This method updates all arrays in this list with the given coordinate</span>
<span class="sd">        values and formatoptions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveBase._register_update.parameters)s</span>
<span class="sd">        auto_update: bool</span>
<span class="sd">            Boolean determining whether or not the :meth:`start_update` method</span>
<span class="sd">            is called at the end. This parameter has no effect if the</span>
<span class="sd">            :attr:`no_auto_update` attribute is set to ``True``.</span>
<span class="sd">        %(InteractiveBase.start_update.parameters.draw)s</span>
<span class="sd">        ``**kwargs``</span>
<span class="sd">            Any other formatoption that shall be updated (additionally to those</span>
<span class="sd">            in `fmt`)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the :attr:`no_auto_update` attribute is True and the given</span>
<span class="sd">        `auto_update` parameter are is False, the update of the plots are</span>
<span class="sd">        registered and conducted at the next call of the :meth:`start_update`</span>
<span class="sd">        method or the next call of this method (if the `auto_update` parameter</span>
<span class="sd">        is then True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="n">replot</span><span class="o">=</span><span class="n">replot</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                              <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span> <span class="ow">or</span> <span class="n">auto_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractiveBase.to_interactive_list"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveBase.to_interactive_list">[docs]</a>    <span class="k">def</span> <span class="nf">to_interactive_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`InteractiveList` that contains this object&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not implemented for the </span><span class="si">%s</span><span class="s1"> class&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">))</span></div></div>


<div class="viewcode-block" id="InteractiveArray"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray">[docs]</a><span class="nd">@xr</span><span class="o">.</span><span class="n">register_dataarray_accessor</span><span class="p">(</span><span class="s1">&#39;psy&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">InteractiveArray</span><span class="p">(</span><span class="n">InteractiveBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interactive psyplot accessor for the data array</span>

<span class="sd">    This class keeps reference to the base :class:`xarray.Dataset` where the</span>
<span class="sd">    :class:`array.DataArray` originates from and enables to switch between the</span>
<span class="sd">    coordinates in the array. Furthermore it has a :attr:`plotter` attribute to</span>
<span class="sd">    enable interactive plotting via an :class:`psyplot.plotter.Plotter`</span>
<span class="sd">    instance.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base dataset this instance gets its data from&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;variable&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">to_dataset</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;variable&#39;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># &#39;variable&#39; Variable not defined</span>
                        <span class="k">pass</span>
                    <span class="k">return</span> <span class="n">ret</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">to_dataset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">])):</span>
                        <span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">ds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onbasechange</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>

    <span class="nd">@base</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onbasechange</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The decoder of this array&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="n">CFDecoder</span><span class="o">.</span><span class="n">get_decoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span>

    <span class="nd">@decoder</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coordinates in the :attr:`base` dataset as int or slice</span>

<span class="sd">        This attribute holds a mapping from the coordinate names of this</span>
<span class="sd">        array to an integer, slice or an array of integer that represent the</span>
<span class="sd">        coordinates in the :attr:`base` dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_idims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idims</span>

    <span class="nd">@idims</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">idims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idims</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@docstrings</span>
    <span class="k">def</span> <span class="nf">_njobs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;%(InteractiveBase._njobs)s&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_njobs</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">logger</span>
    <span class="n">_idims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_base</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># -------------- SIGNALS --------------------------------------------------</span>
    <span class="c1">#: :class:`Signal` to be emiited when the base of the object changes</span>
    <span class="n">onbasechange</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="s1">&#39;_onbasechange&#39;</span><span class="p">)</span>
    <span class="n">_onbasechange</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xarray_obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``*args`` and ``**kwargs`` are essentially the same as for the</span>
<span class="sd">        :class:`xarray.DataArray` method, additional ``**kwargs`` are</span>
<span class="sd">        described below.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        base: xarray.Dataset</span>
<span class="sd">            Default: None. Dataset that serves as the origin of the data</span>
<span class="sd">            contained in this DataArray instance. This will be used if you want</span>
<span class="sd">            to update the coordinates via the :meth:`update` method. If None,</span>
<span class="sd">            this instance will serve as a base as soon as it is needed.</span>
<span class="sd">        decoder: psyplot.CFDecoder</span>
<span class="sd">            The decoder that decodes the `base` dataset and is used to get</span>
<span class="sd">            bounds. If not given, a new :class:`CFDecoder` is created</span>
<span class="sd">        idims: dict</span>
<span class="sd">            Default: None. dictionary with integer values and/or slices in the</span>
<span class="sd">            `base` dictionary. If not given, they are determined automatically</span>
<span class="sd">        %(InteractiveBase.parameters)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span> <span class="o">=</span> <span class="n">xarray_obj</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InteractiveArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registered_updates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="InteractiveArray.init_accessor"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.init_accessor">[docs]</a>    <span class="k">def</span> <span class="nf">init_accessor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the accessor instance</span>

<span class="sd">        This method initializes the accessor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base: xr.Dataset</span>
<span class="sd">            The base dataset for the data</span>
<span class="sd">        idims: dict</span>
<span class="sd">            A mapping from dimension name to indices. If not provided, it is</span>
<span class="sd">            calculated when the :attr:`idims` attribute is accessed</span>
<span class="sd">        decoder: CFDecoder</span>
<span class="sd">            The decoder of this object</span>
<span class="sd">        %(InteractiveBase.parameters)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idims</span> <span class="o">=</span> <span class="n">idims</span>
        <span class="k">if</span> <span class="n">decoder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InteractiveArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iter_base_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An iterator over the base variables in the :attr:`base` dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">VARIABLELABEL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_base_var</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">VARIABLELABEL</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_variable</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]])</span>

    <span class="k">def</span> <span class="nf">_get_base_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">VARIABLELABEL</span><span class="p">:</span> <span class="n">name</span><span class="p">})</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A mapping from the variable name to the variablein the :attr:`base`</span>
<span class="sd">        dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">VARIABLELABEL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">([</span>
                <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_var</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_list</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">VARIABLELABEL</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())])</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_variable</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span><span class="p">]}</span>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;setup_coords.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;dims&#39;</span><span class="p">)</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveArray._register_update&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_register_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span>
                         <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register new dimensions and formatoptions for updating</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method: {&#39;isel&#39;, None, &#39;nearest&#39;, ...}</span>
<span class="sd">            Selection method of the xarray.Dataset to be used for setting the</span>
<span class="sd">            variables from the informations in `dims`.</span>
<span class="sd">            If `method` is &#39;isel&#39;, the :meth:`xarray.Dataset.isel` method is</span>
<span class="sd">            used. Otherwise it sets the `method` parameter for the</span>
<span class="sd">            :meth:`xarray.Dataset.sel` method.</span>
<span class="sd">        %(setup_coords.parameters.dims)s</span>
<span class="sd">        %(InteractiveBase._register_update.parameters)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        start_update&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">method</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;New dimensions were already specified for with the </span><span class="si">%s</span><span class="s2"> method!&quot;</span>
                <span class="s2">&quot; I can not choose a new method </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isstring</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># concatenated array</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dims</span><span class="p">))</span>
        <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="n">replot</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span><span class="p">),</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
            <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_concatenated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates a concatenated array to new dimensions&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">is_unequal</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v1</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># arrays</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">filter_attrs</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Checks whether the attribute is from the base variable&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">or</span>
                    <span class="n">is_unequal</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="n">saved_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">filter_attrs</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="p">)))</span>
        <span class="n">saved_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">base_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;isel&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idims</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">base_dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idims</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base_dims</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span>
                    <span class="n">dims</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">kws</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># the sel method does not work with slice objects</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">dims</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">kws</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">_fix_times</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;coordinates&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span>
                <span class="s1">&#39;coordinates&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_coords</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># res.indexes not existent for xr&lt;0.12</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">saved_name</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">saved_attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">_update_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the array to the new dims from then :attr:`base` dataset&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">is_unequal</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v1</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># arrays</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">filter_attrs</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Checks whether the attribute is from the base variable&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_var</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">or</span>
                    <span class="n">is_unequal</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">base_var</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

        <span class="n">base_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># save attributes that have been changed by the user</span>
        <span class="n">saved_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">filter_attrs</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;isel&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idims</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idims</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">old_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">[:]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base_var</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">dims</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">kws</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># the sel method does not work with slice objects</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">dims</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">kws</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">_fix_times</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="c1"># squeeze the 0-dimensional dimensions</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
                <span class="n">dim</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">old_dims</span><span class="p">)})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_coords</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># res.indexes not existent for xr&lt;0.12</span>
            <span class="k">pass</span>
        <span class="c1"># update to old attributes</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">saved_attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="InteractiveArray.shiftlon"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.shiftlon">[docs]</a>    <span class="k">def</span> <span class="nf">shiftlon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_longitude</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift longitudes and the data so that they match map projection region.</span>

<span class="sd">        Only valid for cylindrical/pseudo-cylindrical global projections and</span>
<span class="sd">        data on regular lat/lon grids. longitudes need to be 1D.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_longitude</span>
<span class="sd">            center of map projection region</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        This function is copied and taken from the</span>
<span class="sd">        :class:`mpl_toolkits.basemap.Basemap` class. The only difference is</span>
<span class="sd">        that we do not mask values outside the map projection region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xr_version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;xarray&gt;=0.10 is required for the shiftlon method!&quot;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">xname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">xname</span><span class="p">,</span> <span class="n">yname</span><span class="p">]])</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">indexes</span><span class="p">))</span>
                <span class="n">shifted</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">shiftlon</span><span class="p">(</span><span class="n">central_longitude</span><span class="p">)</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifted</span><span class="o">.</span><span class="n">values</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">shifted</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifted</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>

            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">xname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">xname</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">lon</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">lonsin</span> <span class="o">=</span> <span class="n">lon</span><span class="o">.</span><span class="n">values</span>
        <span class="n">datain</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">clon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">central_longitude</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lonsin</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;1D longitudes required&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">clon</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Central longitude must be a scalar, not &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">-dimensional!&quot;</span> <span class="o">%</span> <span class="n">clon</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="n">lonsin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lonsin</span> <span class="o">&gt;</span> <span class="n">clon</span><span class="o">+</span><span class="mi">180</span><span class="p">,</span> <span class="n">lonsin</span><span class="o">-</span><span class="mi">360</span><span class="p">,</span> <span class="n">lonsin</span><span class="p">)</span>
        <span class="n">lonsin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lonsin</span> <span class="o">&lt;</span> <span class="n">clon</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="n">lonsin</span><span class="o">+</span><span class="mi">360</span><span class="p">,</span> <span class="n">lonsin</span><span class="p">)</span>
        <span class="n">londiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lonsin</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lonsin</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">londiff_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">londiff</span><span class="p">)</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="mf">360.</span><span class="o">-</span><span class="n">londiff_sort</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">itemindex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonsin</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">londiff</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">itemindex</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># check to see if cyclic (wraparound) point included</span>
            <span class="c1"># if so, remove it.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lonsin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lonsin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1.e-4</span><span class="p">:</span>
                <span class="n">hascyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">lonsin_save</span> <span class="o">=</span> <span class="n">lonsin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">lonsin</span> <span class="o">=</span> <span class="n">lonsin</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">datain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">datain_save</span> <span class="o">=</span> <span class="n">datain</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">datain</span> <span class="o">=</span> <span class="n">datain</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hascyclic</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">lonsin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">lonsin</span><span class="p">,</span> <span class="n">itemindex</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">datain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">datain</span><span class="p">,</span> <span class="n">itemindex</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">ix</span><span class="p">])</span>
            <span class="c1"># add cyclic point back at beginning.</span>
            <span class="k">if</span> <span class="n">hascyclic</span><span class="p">:</span>
                <span class="n">lonsin_save</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">lonsin</span>
                <span class="n">lonsin_save</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lonsin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">360.</span>
                <span class="n">lonsin</span> <span class="o">=</span> <span class="n">lonsin_save</span>
                <span class="k">if</span> <span class="n">datain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">datain_save</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">datain</span>
                    <span class="n">datain_save</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">datain</span> <span class="o">=</span> <span class="n">datain_save</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">datain</span><span class="p">)</span>
        <span class="n">lon</span><span class="o">.</span><span class="n">values</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lonsin</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">lon</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="InteractiveArray.start_update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.start_update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conduct the formerly registered updates</span>

<span class="sd">        This method conducts the updates that have been registered via the</span>
<span class="sd">        :meth:`update` method. You can call this method if the</span>
<span class="sd">        :attr:`no_auto_update` attribute of this instance is True and the</span>
<span class="sd">        `auto_update` parameter in the :meth:`update` method has been set to</span>
<span class="sd">        False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveBase.start_update.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(InteractiveBase.start_update.returns)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`no_auto_update`, update</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">filter_attrs</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">or</span>
                    <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">queues</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># make sure that no plot is updated during gathering the data</span>
            <span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span>
            <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span>
            <span class="k">if</span> <span class="n">dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">VARIABLELABEL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_concatenated</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_array</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">queues</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_dims</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onupdate</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finish_all</span><span class="p">(</span><span class="n">queues</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="n">queues</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractiveArray.update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveArray.update&#39;</span><span class="p">,</span>
                              <span class="n">sections</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Notes&#39;</span><span class="p">])</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">auto_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the coordinates and the plot</span>

<span class="sd">        This method updates all arrays in this list with the given coordinate</span>
<span class="sd">        values and formatoptions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveArray._register_update.parameters)s</span>
<span class="sd">        auto_update: bool</span>
<span class="sd">            Boolean determining whether or not the :meth:`start_update` method</span>
<span class="sd">            is called after the end.</span>
<span class="sd">        %(InteractiveBase.start_update.parameters)s</span>
<span class="sd">        ``**kwargs``</span>
<span class="sd">            Any other formatoption or dimension that shall be updated</span>
<span class="sd">            (additionally to those in `fmt` and `dims`)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When updating to a new array while trying to set the dimensions at the</span>
<span class="sd">        same time, you have to specify the new dimensions via the `dims`</span>
<span class="sd">        parameter, e.g.::</span>

<span class="sd">            da.psy.update(name=&#39;new_name&#39;, dims={&#39;new_dim&#39;: 3})</span>

<span class="sd">        if ``&#39;new_dim&#39;`` is not yet a dimension of this array</span>

<span class="sd">        %(InteractiveBase.update.notes)s&quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
        <span class="n">vars_and_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">]))</span>
        <span class="n">furtherdims</span><span class="p">,</span> <span class="n">furtherfmt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">vars_and_coords</span><span class="p">)</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">furtherdims</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">furtherfmt</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="n">replot</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                              <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span> <span class="ow">or</span> <span class="n">auto_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_short_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intend</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maybe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">str_intend</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">intend</span>
        <span class="k">if</span> <span class="s1">&#39;variable&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s1">&#39;, with (</span><span class="si">%s</span><span class="s1">)=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">return</span> <span class="n">str_intend</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%i</span><span class="s2">-dim </span><span class="si">%s</span><span class="s2"> of </span><span class="si">%s%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
            <span class="n">dims</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">format_item</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="InteractiveArray.isel"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.isel">[docs]</a>    <span class="k">def</span> <span class="nf">isel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># reimplemented to keep the base. The doc is set below</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="InteractiveArray.sel"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.sel">[docs]</a>    <span class="k">def</span> <span class="nf">sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># reimplemented to keep the base. The doc is set below</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="InteractiveArray.copy"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the array</span>

<span class="sd">        This method returns a copy of the underlying array in the :attr:`arr`</span>
<span class="sd">        attribute. It is more stable because it creates a new `psy` accessor&quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span> <span class="o">=</span> <span class="n">InteractiveArray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># attribute is read-only for xarray &gt;=0.13</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">arr</span></div>

<div class="viewcode-block" id="InteractiveArray.to_interactive_list"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.to_interactive_list">[docs]</a>    <span class="k">def</span> <span class="nf">to_interactive_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">InteractiveList</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">arr_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractiveArray.get_coord"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.get_coord">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;InteractiveArray.get_coord&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The x-coordinate of this data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what: {&#39;t&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;}</span>
<span class="sd">            The letter of the axis</span>
<span class="sd">        base: bool</span>
<span class="sd">            If True, use the base variable in the :attr:`base` dataset.&quot;&quot;&quot;</span>
        <span class="n">what</span> <span class="o">=</span> <span class="n">what</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">,</span> <span class="s1">&#39;get_&#39;</span> <span class="o">+</span> <span class="n">what</span><span class="p">)(</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">))</span> <span class="k">if</span> <span class="n">base</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractiveArray.get_dim"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.get_dim">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">get_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the x-dimension of this data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveArray.get_coord.parameters)s&quot;&quot;&quot;</span>
        <span class="n">what</span> <span class="o">=</span> <span class="n">what</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">,</span> <span class="s1">&#39;get_</span><span class="si">%s</span><span class="s1">name&#39;</span> <span class="o">%</span> <span class="n">what</span><span class="p">)(</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">))</span> <span class="k">if</span> <span class="n">base</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span></div>

    <span class="c1"># ------------------ Calculations -----------------------------------------</span>

    <span class="k">def</span> <span class="nf">_gridweights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the gridweights with a simple rectangular approximation&quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="c1"># convert the units</span>
        <span class="n">xcoord_orig</span> <span class="o">=</span> <span class="n">xcoord</span>
        <span class="n">ycoord_orig</span> <span class="o">=</span> <span class="n">ycoord</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">in_metres</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">in_degree</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s1">&#39;deg&#39;</span> <span class="ow">in</span> <span class="n">units</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="s1">&#39;rad&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">units</span> <span class="ow">and</span> <span class="s1">&#39;lon&#39;</span> <span class="ow">in</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span>
                <span class="s1">&#39;lat&#39;</span> <span class="ow">in</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">xcoord</span> <span class="o">=</span> <span class="n">xcoord</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
            <span class="n">ycoord</span> <span class="o">=</span> <span class="n">ycoord</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
            <span class="n">in_degree</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="s1">&#39;rad&#39;</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_metres</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># calculate the gridcell boundaries</span>
        <span class="n">xbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_plotbounds</span><span class="p">(</span><span class="n">xcoord</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ybounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_plotbounds</span><span class="p">(</span><span class="n">ycoord</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xbounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xbounds</span><span class="p">,</span> <span class="n">ybounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xbounds</span><span class="p">,</span> <span class="n">ybounds</span><span class="p">)</span>

        <span class="c1"># calculate the weights based on the units</span>
        <span class="k">if</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">is_unstructured</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">] - Curvilinear grids are not supported! &quot;</span>
                 <span class="s2">&quot;Using constant grid cell area weights!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                 <span class="n">PsyPlotRuntimeWarning</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xcoord</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">in_metres</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xbounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xbounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ybounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ybounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xbounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xbounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ybounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ybounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># normalize the weights by dividing through the sum</span>
        <span class="k">if</span> <span class="n">in_degree</span><span class="p">:</span>
            <span class="n">xmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xcoord_orig</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">400</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">xcoord_orig</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">400</span><span class="p">)</span>
            <span class="n">ymask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ycoord_orig</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">200</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ycoord_orig</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xmask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">ymask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">xmask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">xmask</span><span class="p">,</span> <span class="n">ymask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xmask</span><span class="p">,</span> <span class="n">ymask</span><span class="p">)</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">xmask</span> <span class="o">|</span> <span class="n">ymask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
            <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weights</span>

    <span class="k">def</span> <span class="nf">_gridweights_cdo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the gridweights using CDOs&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cdo</span> <span class="kn">import</span> <span class="n">Cdo</span>
        <span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">NamedTemporaryFile</span>
        <span class="n">sdims</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)}</span>
        <span class="n">cdo</span> <span class="o">=</span> <span class="n">Cdo</span><span class="p">()</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;psy&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.nc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="n">sdims</span><span class="p">})</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bounds</span> <span class="ow">and</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">sdims</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">bounds</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)):</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">bounds</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sdims</span><span class="p">}</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">bounds</span><span class="p">]</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                               <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">to_netcdf</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">cdo</span><span class="o">.</span><span class="n">gridweights</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span> <span class="n">returnArray</span><span class="o">=</span><span class="s1">&#39;cell_weights&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_weights_to_da</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepshape</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the 2D weights into a DataArray and potentially enlarge it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">sdims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>   <span class="c1"># unstructured grids</span>
            <span class="n">sdims</span> <span class="o">=</span> <span class="n">sdims</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sdims</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># reshape and expand if necessary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepdims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keepshape</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">ycoord</span><span class="p">,</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">xcoord</span><span class="p">}</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">sdims</span>
        <span class="k">elif</span> <span class="n">keepshape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">with_dask</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">dask.array</span> <span class="kn">import</span> <span class="n">broadcast_to</span><span class="p">,</span> <span class="n">notnull</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">broadcast_to</span><span class="p">,</span> <span class="n">isnan</span>

                <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="k">return</span> <span class="o">~</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="n">dims</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># set nans to zero weigths. This step takes quite a lot of time for</span>
            <span class="c1"># large arrays since it involves a copy of the entire `arr`</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">notnull</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="c1"># normalize the weights</span>
            <span class="k">if</span> <span class="n">with_dask</span><span class="p">:</span>
                <span class="n">summed_weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sdims</span><span class="p">)),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">summed_weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sdims</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">summed_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sdims</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">})</span><span class="o">.</span><span class="n">coords</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sdims</span> <span class="k">else</span> <span class="n">s</span>
                      <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cell_weights&#39;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

<div class="viewcode-block" id="InteractiveArray.gridweights"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.gridweights">[docs]</a>    <span class="k">def</span> <span class="nf">gridweights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepshape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_cdo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the cell weights for each grid cell</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keepdims: bool</span>
<span class="sd">            If True, keep the number of dimensions</span>
<span class="sd">        keepshape: bool</span>
<span class="sd">            If True, keep the exact shape as the source array and the missing</span>
<span class="sd">            values in the array are masked</span>
<span class="sd">        use_cdo: bool or None</span>
<span class="sd">            If True, use Climate Data Operators (CDOs) to calculate the</span>
<span class="sd">            weights. Note that this is used automatically for unstructured</span>
<span class="sd">            grids. If None, it depends on the ``&#39;gridweights.use_cdo&#39;``</span>
<span class="sd">            item in the :attr:`psyplot.rcParams`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            The 2D-DataArray with the grid weights&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_cdo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_cdo</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;gridweights.use_cdo&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_cdo</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">is_unstructured</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">use_cdo</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">use_cdo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">use_cdo</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridweights_cdo</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">use_cdo</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridweights</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridweights</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights_to_da</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                                   <span class="n">keepshape</span><span class="o">=</span><span class="n">keepshape</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fldaverage_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Masked array, xname, yname and axis for calculating the average&quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span>
        <span class="n">sdims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">sdims</span> <span class="o">=</span> <span class="n">sdims</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sdims</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">,</span> <span class="n">sdims</span><span class="p">,</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">_insert_fldmean_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">sdims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
        <span class="n">xbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">max</span><span class="p">()]])</span>
        <span class="n">ybounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">max</span><span class="p">()]])</span>
        <span class="n">xdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;bnds&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;bnds&#39;</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">ydims</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bnds&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;bnds&#39;</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">xattrs</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">xattrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">yattrs</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">yattrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">da</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span>
            <span class="n">xdims</span><span class="p">,</span> <span class="n">xbounds</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">xbounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="o">=</span><span class="n">xattrs</span><span class="p">)</span>
        <span class="n">da</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span>
            <span class="n">ydims</span><span class="p">,</span> <span class="n">ybounds</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">ybounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="o">=</span><span class="n">yattrs</span><span class="p">)</span>

<div class="viewcode-block" id="InteractiveArray.fldmean"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.fldmean">[docs]</a>    <span class="k">def</span> <span class="nf">fldmean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the weighted mean over the x- and y-dimension</span>

<span class="sd">        This method calculates the weighted mean of the spatial dimensions.</span>
<span class="sd">        Weights are calculated using the :meth:`gridweights` method, missing</span>
<span class="sd">        values are ignored. x- and y-dimensions are identified using the</span>
<span class="sd">        :attr:`decoder`s :meth:`~CFDecoder.get_xname` and</span>
<span class="sd">        :meth:`~CFDecoder.get_yname` methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keepdims: bool</span>
<span class="sd">            If True, the dimensionality of this array is maintained</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.DataArray</span>
<span class="sd">            The computed fldmeans. The dimensions are the same as in this</span>
<span class="sd">            array, only the spatial dimensions are omitted if `keepdims` is</span>
<span class="sd">            False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fldstd: For calculating the weighted standard deviation</span>
<span class="sd">        fldpctl: For calculating weighted percentiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gridweights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridweights</span><span class="p">()</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">sdims</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fldaverage_args</span><span class="p">()</span>

        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_x</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)),</span>
                                    <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)),</span>
                                    <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">((</span><span class="n">arr</span> <span class="o">*</span> <span class="n">gridweights</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">gridweights</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">arr</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="n">means</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sdims</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="n">means</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">xcoord</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">means</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ycoord</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">means</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">means</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">means</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span>
        <span class="n">means</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert_fldmean_bounds</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>
        <span class="n">means</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">means</span></div>

<div class="viewcode-block" id="InteractiveArray.fldstd"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.fldstd">[docs]</a>    <span class="k">def</span> <span class="nf">fldstd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the weighted standard deviation over x- and y-dimension</span>

<span class="sd">        This method calculates the weighted standard deviation of the spatial</span>
<span class="sd">        dimensions. Weights are calculated using the :meth:`gridweights`</span>
<span class="sd">        method, missing values are ignored. x- and y-dimensions are identified</span>
<span class="sd">        using the :attr:`decoder`s :meth:`~CFDecoder.get_xname` and</span>
<span class="sd">        :meth:`~CFDecoder.get_yname` methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keepdims: bool</span>
<span class="sd">            If True, the dimensionality of this array is maintained</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.DataArray</span>
<span class="sd">            The computed standard deviations. The dimensions are the same as</span>
<span class="sd">            in this array, only the spatial dimensions are omitted if</span>
<span class="sd">            `keepdims` is  False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fldmean: For calculating the weighted mean</span>
<span class="sd">        fldpctl: For calculating weighted percentiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">sdims</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fldaverage_args</span><span class="p">()</span>
        <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fldmean</span><span class="p">(</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridweights</span><span class="p">(</span><span class="n">keepshape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">variance</span> <span class="o">=</span> <span class="p">((</span><span class="n">arr</span> <span class="o">-</span> <span class="n">means</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sdims</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variance</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sdims</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">variance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">coord</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span>
                    <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variance</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sdims</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">variance</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">coord</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span>
                    <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">variance</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">std</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">std</span></div>

<div class="viewcode-block" id="InteractiveArray.fldpctl"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveArray.fldpctl">[docs]</a>    <span class="k">def</span> <span class="nf">fldpctl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the percentiles along the x- and y-dimensions</span>

<span class="sd">        This method calculates the specified percentiles along the given</span>
<span class="sd">        dimension. Percentiles are weighted by the :meth:`gridweights` method</span>
<span class="sd">        and missing values are ignored. x- and y-dimensions are estimated</span>
<span class="sd">        through the :attr:`decoder`s :meth:`~CFDecoder.get_xname` and</span>
<span class="sd">        :meth:`~CFDecoder.get_yname` methods</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q: float or list of floats between 0 and 100</span>
<span class="sd">            The quantiles to estimate</span>
<span class="sd">        keepdims: bool</span>
<span class="sd">            If True, the number of dimensions of the array are maintained</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.DataArray</span>
<span class="sd">            The data array with the dimensions. If `q` is a list or `keepdims`</span>
<span class="sd">            is True, the first dimension will be the percentile ``&#39;pctl&#39;``.</span>
<span class="sd">            The other dimensions are the same as in this array, only the</span>
<span class="sd">            spatial dimensions are omitted if `keepdims` is False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fldstd: For calculating the weighted standard deviation</span>
<span class="sd">        fldmean: For calculating the weighted mean</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This method does load the entire array into memory! So take care if you</span>
<span class="sd">        handle big data.&quot;&quot;&quot;</span>
        <span class="n">gridweights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridweights</span><span class="p">(</span><span class="n">keepshape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;q should be in [0, 100]&#39;</span><span class="p">)</span>
        <span class="n">reduce_shape</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sdims</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fldaverage_args</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">gridweights</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># flatten along the spatial axis</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)]),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">):])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)]),</span> <span class="p">)</span> <span class="o">+</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">):])</span>

        <span class="c1"># sort the data</span>
        <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">all_indices</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">indices</span>
            <span class="n">data</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span>
                    <span class="n">sorter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">)])</span>
            <span class="n">weights</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span>
                    <span class="n">sorter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">)])</span>

        <span class="c1"># compute the percentiles</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">weights</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">notnull</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">notnull</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">notnull</span><span class="p">])</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
        <span class="n">pctl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">all_indices</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">indices</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
            <span class="n">pctl</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">q</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="n">mask</span><span class="p">],</span>
                <span class="n">data</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="n">mask</span><span class="p">]))</span>

        <span class="c1"># setup the data array and it&#39;s coordinates</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_x</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)),</span>
                                    <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)),</span>
                                    <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="n">pctl</span> <span class="o">=</span> <span class="n">pctl</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">xcoord</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ycoord</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reduce_shape</span><span class="p">:</span>
            <span class="n">pctl</span> <span class="o">=</span> <span class="n">pctl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coords</span><span class="p">[</span><span class="s1">&#39;pctl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Variable</span><span class="p">((),</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">,</span>
                                         <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Percentile&#39;</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[</span><span class="s1">&#39;pctl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="s1">&#39;pctl&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">q</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">,</span>
                                         <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Percentile&#39;</span><span class="p">})</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;pctl&#39;</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">dims</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">xcoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">ycoord</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ycoord</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_bnds&#39;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                  <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">pctl</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                           <span class="n">attrs</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert_fldmean_bounds</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="n">isel</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">isel</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="n">sel</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">sel</span><span class="o">.</span><span class="vm">__doc__</span></div>


<div class="viewcode-block" id="ArrayList"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList">[docs]</a><span class="k">class</span> <span class="nc">ArrayList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for creating a list of interactive arrays from a dataset</span>

<span class="sd">    This list contains and manages :class:`InteractiveArray` instances&quot;&quot;&quot;</span>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;InteractiveBase.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;auto_update&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensions of the arrays in this list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dims_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensions of the arrays in this list that are used in all arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">,</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;dims_intersect&#39;</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">arr_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Names of the arrays (!not of the variables!) in this list</span>

<span class="sd">        This attribute can be set with an iterable of unique names to change</span>
<span class="sd">        the array names of the data objects in this list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@arr_names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">arr_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Got </span><span class="si">%i</span><span class="s2"> unique array names for </span><span class="si">%i</span><span class="s2"> data objects!&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">arr</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">=</span> <span class="n">n</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of the variable in this list&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The variable names for each of the arrays in this list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">_get_variable_names</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ArrayList</span><span class="p">)</span> <span class="k">else</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">all_names</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dimensions for each of the arrays in this list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">_get_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ArrayList</span><span class="p">)</span> <span class="k">else</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">all_dims</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_unstructured</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A boolean for each array whether it is unstructured or not&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">is_unstructured</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ArrayList</span><span class="p">)</span> <span class="k">else</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">is_unstructured</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Names of the coordinates of the arrays in this list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coordinates of the arrays in this list that are used in all arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">,</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;coords_intersect&#39;</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">with_plotter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The arrays in this instance that are visualized with a plotter&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="p">(</span><span class="n">arr</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">auto_update</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_update</span><span class="p">))</span>

    <span class="n">no_auto_update</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_no_auto_update_getter</span><span class="p">,</span>
                              <span class="n">doc</span><span class="o">=</span><span class="n">_no_auto_update_getter</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="nd">@no_auto_update</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">no_auto_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">no_auto_update</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`logging.Logger` of this instance&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing...&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>

    <span class="nd">@logger</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of all the :class:`xarray.DataArray` instances in this list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="p">([</span><span class="n">arr</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">)</span> <span class="k">else</span> <span class="n">arr</span><span class="o">.</span><span class="n">arrays</span>
             <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)))</span>

<div class="viewcode-block" id="ArrayList.rename"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.rename">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList.rename&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Raises&#39;</span><span class="p">])</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename an array to find a name that isn&#39;t already in the list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr: InteractiveBase</span>
<span class="sd">            A :class:`InteractiveArray` or :class:`InteractiveList` instance</span>
<span class="sd">            whose name shall be checked</span>
<span class="sd">        new_name: bool or str</span>
<span class="sd">            If False, and the ``arr_name`` attribute of the new array is</span>
<span class="sd">            already in the list, a ValueError is raised.</span>
<span class="sd">            If True and the ``arr_name`` attribute of the new array is not</span>
<span class="sd">            already in the list, the name is not changed. Otherwise, if the</span>
<span class="sd">            array name is already in use, `new_name` is set to &#39;arr{0}&#39;.</span>
<span class="sd">            If not True, this will be used for renaming (if the array name of</span>
<span class="sd">            `arr` is in use or not). ``&#39;{0}&#39;`` is replaced by a counter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        InteractiveBase</span>
<span class="sd">            `arr` with changed ``arr_name`` attribute</span>
<span class="sd">        bool or None</span>
<span class="sd">            True, if the array has been renamed, False if not and None if the</span>
<span class="sd">            array is already in the list</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If it was impossible to find a name that isn&#39;t already  in the list</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `new_name` is False and the array is already in the list&quot;&quot;&quot;</span>
        <span class="n">name_in_me</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_names</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name_in_me</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">name_in_me</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_array</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Array name </span><span class="si">%s</span><span class="s2"> is already in use! Set the `new_name` &quot;</span>
                    <span class="s2">&quot;parameter to None for renaming!&quot;</span> <span class="o">%</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">new_name</span> <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;arr</span><span class="si">{0}</span><span class="s1">&#39;</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_available_name</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">arr</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">,</span> <span class="kc">None</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;ArrayList.rename.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;new_name&#39;</span><span class="p">)</span>
    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;InteractiveBase.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;auto_update&#39;</span><span class="p">)</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="p">[],</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{},</span> <span class="n">auto_update</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable: iterable</span>
<span class="sd">            The iterable (e.g. another list) defining this list</span>
<span class="sd">        attrs: dict-like or iterable, optional</span>
<span class="sd">            Global attributes of this list</span>
<span class="sd">        %(InteractiveBase.parameters.auto_update)s</span>
<span class="sd">        %(ArrayList.rename.parameters.new_name)s&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ArrayList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">auto_update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">auto_update</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lists.auto_update&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_update</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">auto_update</span><span class="p">)</span>
        <span class="c1"># append the data in order to set the correct names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;psy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                   <span class="n">InteractiveBase</span><span class="p">),</span>
            <span class="n">iterable</span><span class="p">),</span> <span class="n">new_name</span><span class="o">=</span><span class="n">new_name</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayList.copy"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of the list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep: bool</span>
<span class="sd">            If False (default), only the list is copied and not the contained</span>
<span class="sd">            arrays, otherwise the contained arrays are deep copied&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">[:],</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                  <span class="n">auto_update</span><span class="o">=</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">auto_update</span><span class="o">=</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_update</span><span class="p">))</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;InteractiveArray.update.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayList.from_dataset"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.from_dataset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList.from_dataset&#39;</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Other Parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;Returns&#39;</span><span class="p">])</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">from_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">default_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">auto_update</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an ArrayList instance from an existing base dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base: xarray.Dataset</span>
<span class="sd">            Dataset instance that is used as reference</span>
<span class="sd">        %(InteractiveArray.update.parameters.method)s</span>
<span class="sd">        %(InteractiveBase.parameters.auto_update)s</span>
<span class="sd">        prefer_list: bool</span>
<span class="sd">            If True and multiple variable names pher array are found, the</span>
<span class="sd">            :class:`InteractiveList` class is used. Otherwise the arrays are</span>
<span class="sd">            put together into one :class:`InteractiveArray`.</span>
<span class="sd">        default_slice: indexer</span>
<span class="sd">            Index (e.g. 0 if `method` is &#39;isel&#39;) that shall be used for</span>
<span class="sd">            dimensions not covered by `dims` and `furtherdims`. If None, the</span>
<span class="sd">            whole slice will be used. Note that the `default_slice` is always</span>
<span class="sd">            based on the `isel` method.</span>
<span class="sd">        decoder: CFDecoder or dict</span>
<span class="sd">            Arguments for the decoder. This can be one of</span>

<span class="sd">            - an instance of :class:`CFDecoder`</span>
<span class="sd">            - a subclass of :class:`CFDecoder`</span>
<span class="sd">            - a dictionary with keyword-arguments to the automatically</span>
<span class="sd">              determined decoder class</span>
<span class="sd">            - None to automatically set the decoder</span>
<span class="sd">        squeeze: bool, optional</span>
<span class="sd">            Default True. If True, and the created arrays have a an axes with</span>
<span class="sd">            length 1, it is removed from the dimension list (e.g. an array</span>
<span class="sd">            with shape (3, 4, 1, 5) will be squeezed to shape (3, 4, 5))</span>
<span class="sd">        attrs: dict, optional</span>
<span class="sd">            Meta attributes that shall be assigned to the selected data arrays</span>
<span class="sd">            (additional to those stored in the `base` dataset)</span>
<span class="sd">        load: bool or dict</span>
<span class="sd">            If True, load the data from the dataset using the</span>
<span class="sd">            :meth:`xarray.DataArray.load` method. If :class:`dict`, those will</span>
<span class="sd">            be given to the above mentioned ``load`` method</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(setup_coords.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayList</span>
<span class="sd">            The list with the specified :class:`InteractiveArray` instances</span>
<span class="sd">            that hold a reference to the given `base`&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">load</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">maybe_load</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">load</span><span class="p">()</span> <span class="k">if</span> <span class="n">load</span> <span class="k">else</span> <span class="n">arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">maybe_load</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">**</span><span class="n">load</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">iter_dims</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Split the given dictionary into multiples and iterate over it&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dims</span><span class="p">:</span>
                <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">{}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">safe_list</span><span class="p">,</span> <span class="n">dims</span><span class="o">.</span><span class="n">values</span><span class="p">()))):</span>
                    <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">recursive_selection</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">safe_list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">prefer_list</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;arr</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">InteractiveList</span><span class="p">(</span>
                    <span class="n">starmap</span><span class="p">(</span><span class="n">sel_method</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">iter_dims</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">names</span><span class="p">)),</span>
                    <span class="n">auto_update</span><span class="o">=</span><span class="n">auto_update</span><span class="p">,</span> <span class="n">arr_name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sel_method</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sel_method</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">ds2arr</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">base_var</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">base_var</span><span class="o">.</span><span class="n">attrs</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;coordinates&#39;</span> <span class="ow">in</span> <span class="n">base_var</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_var</span><span class="o">.</span><span class="n">encoding</span><span class="p">[</span>
                    <span class="s1">&#39;coordinates&#39;</span><span class="p">]</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arr</span>

        <span class="n">decoder_input</span> <span class="o">=</span> <span class="n">decoder</span>

        <span class="k">def</span> <span class="nf">get_decoder</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">decoder_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CFDecoder</span><span class="o">.</span><span class="n">get_decoder</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decoder_input</span><span class="p">,</span> <span class="n">CFDecoder</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">decoder_input</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decoder_input</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">CFDecoder</span><span class="o">.</span><span class="n">get_decoder</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="o">**</span><span class="n">decoder_input</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">decoder_input</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">add_missing_dimensions</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c1"># add the missing dimensions to the dataset. This is not anymore</span>
            <span class="c1"># done by default from xarray &gt;= 0.9 but we need it to ensure the</span>
            <span class="c1"># interactive treatment of DataArrays</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;variable&#39;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">:</span>
                <span class="n">base</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">squeeze_array</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">squeeze_array</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arr</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;isel&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">sel_method</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">recursive_selection</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span>
                      <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">name</span><span class="p">)):</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">decoder</span> <span class="o">=</span> <span class="n">get_decoder</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
                    <span class="n">decoder</span> <span class="o">=</span> <span class="n">get_decoder</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dims</span><span class="p">)</span>
                <span class="n">def_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">default_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                    <span class="n">default_slice</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                    <span class="n">dim</span><span class="p">:</span> <span class="n">def_slice</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                        <span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="s1">&#39;variable&#39;</span><span class="p">})</span>
                <span class="n">add_missing_dimensions</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="o">**</span><span class="n">dims</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ds2arr</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">squeeze_array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="c1"># delete the variable dimension for the idims</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;variable&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">init_accessor</span><span class="p">(</span><span class="n">arr_name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">idims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                                      <span class="n">decoder</span><span class="o">=</span><span class="n">decoder</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">maybe_load</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">sel_method</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">recursive_selection</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span>
                      <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">name</span><span class="p">)):</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">decoder</span> <span class="o">=</span> <span class="n">get_decoder</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
                    <span class="n">decoder</span> <span class="o">=</span> <span class="n">get_decoder</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dims</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">default_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                            <span class="n">dim</span><span class="p">:</span> <span class="n">default_slice</span>
                            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="s1">&#39;variable&#39;</span><span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                            <span class="n">dim</span><span class="p">:</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">default_slice</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="s1">&#39;variable&#39;</span><span class="p">})</span>
                <span class="n">kws</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">kws</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
                <span class="c1"># the sel method does not work with slice objects</span>
                <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dims</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                            <span class="n">kws</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>  <span class="c1"># the full slice is the default</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">kws</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">add_missing_dimensions</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">_fix_times</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ds2arr</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">squeeze_array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">init_accessor</span><span class="p">(</span><span class="n">arr_name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">decoder</span><span class="o">=</span><span class="n">decoder</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">maybe_load</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">default_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">variables</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">default_names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_names</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">setup_coords</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># check coordinates</span>
        <span class="n">possible_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">names</span><span class="p">))):</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">check_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">possible_keys</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;dimension&#39;</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">sel_method</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">names</span><span class="p">)),</span>
                       <span class="n">attrs</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">auto_update</span><span class="o">=</span><span class="n">auto_update</span><span class="p">)</span>
        <span class="c1"># convert to interactive lists if an instance is not</span>
        <span class="k">if</span> <span class="n">prefer_list</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">instance</span><span class="p">):</span>
            <span class="c1"># if any instance is an interactive list, than convert the others</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">instance</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">):</span>
                        <span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">InteractiveList</span><span class="p">([</span><span class="n">arr</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># put everything into one single interactive list</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([</span><span class="n">InteractiveList</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                                                <span class="n">auto_update</span><span class="o">=</span><span class="n">auto_update</span><span class="p">)])</span>
                <span class="n">instance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">=</span> <span class="n">instance</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span>
        <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">instance</span><span class="p">:</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_dsnames</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ignore_keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attrs&#39;</span><span class="p">,</span> <span class="s1">&#39;plotter&#39;</span><span class="p">,</span> <span class="s1">&#39;ds&#39;</span><span class="p">],</span>
                     <span class="n">concat_dim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursive method to get all the file names out of a dictionary</span>
<span class="sd">        `data` created with the :meth`array_info` method&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">filter_ignores</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore_keys</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;fname&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;store&#39;</span><span class="p">]]</span> <span class="o">+</span>
                <span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concat_dim&#39;</span><span class="p">)]</span> <span class="k">if</span> <span class="n">concat_dim</span> <span class="k">else</span> <span class="p">[])</span> <span class="o">+</span>
                <span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;combine&#39;</span><span class="p">)]</span> <span class="k">if</span> <span class="n">combine</span> <span class="k">else</span> <span class="p">[]))}</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_dsnames</span><span class="p">,</span> <span class="n">concat_dim</span><span class="o">=</span><span class="n">concat_dim</span><span class="p">,</span>
                                      <span class="n">combine</span><span class="o">=</span><span class="n">combine</span><span class="p">,</span>
                                      <span class="n">ignore_keys</span><span class="o">=</span><span class="n">ignore_keys</span><span class="p">),</span>
                              <span class="nb">dict</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">filter_ignores</span><span class="p">,</span>
                                          <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_ds_descriptions</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ds_description</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;arr&#39;</span><span class="p">},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">new_dict</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">new_dict</span><span class="p">)</span>
        <span class="n">ds_description</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ds_description</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_ds_descriptions_unsorted</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">num</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Could not find either the dataset number nor the dataset &#39;</span>
                    <span class="s1">&#39;in the data! However one must be provided.&#39;</span><span class="p">)</span>
            <span class="n">d_ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;arr&#39;</span><span class="p">:</span>
                    <span class="n">d_ret</span><span class="p">[</span><span class="s1">&#39;arr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;arr&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d_ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_ds_descriptions_unsorted</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ignore_keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attrs&#39;</span><span class="p">,</span> <span class="s1">&#39;plotter&#39;</span><span class="p">],</span> <span class="n">nums</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursive method to get all the file names or datasets out of a</span>
<span class="sd">        dictionary `data` created with the :meth`array_info` method&quot;&quot;&quot;</span>
        <span class="n">ds_description</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;arr&#39;</span><span class="p">,</span> <span class="s1">&#39;store&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="s1">&#39;ds&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="c1"># make sure that the data set has a number assigned to it</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">num</span>
        <span class="n">keys_in_data</span> <span class="o">=</span> <span class="n">ds_description</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keys_in_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_in_data</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ignore_keys</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_ds_descriptions_unsorted</span><span class="p">,</span>
                       <span class="n">ignore_keys</span><span class="o">=</span><span class="n">ignore_keys</span><span class="p">,</span> <span class="n">nums</span><span class="o">=</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">d</span><span class="p">,</span>
                          <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">data</span><span class="p">))))</span>

<div class="viewcode-block" id="ArrayList.from_dict"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList.from_dict&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">alternative_paths</span><span class="o">=</span><span class="p">{},</span> <span class="n">datasets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">pwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attrs&#39;</span><span class="p">,</span> <span class="s1">&#39;plotter&#39;</span><span class="p">,</span> <span class="s1">&#39;ds&#39;</span><span class="p">],</span>
                  <span class="n">only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chname</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list from the dictionary returned by :meth:`array_info`</span>

<span class="sd">        This classmethod creates an :class:`~psyplot.data.ArrayList` instance</span>
<span class="sd">        from a dictionary containing filename, dimension infos and array names</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d: dict</span>
<span class="sd">            The dictionary holding the data</span>
<span class="sd">        alternative_paths: dict or list or str</span>
<span class="sd">            A mapping from original filenames as used in `d` to filenames that</span>
<span class="sd">            shall be used instead. If `alternative_paths` is not None,</span>
<span class="sd">            datasets must be None. Paths must be accessible from the current</span>
<span class="sd">            working directory.</span>
<span class="sd">            If `alternative_paths` is a list (or any other iterable) is</span>
<span class="sd">            provided, the file names will be replaced as they appear in `d`</span>
<span class="sd">            (note that this is very unsafe if `d` is not and OrderedDict)</span>
<span class="sd">        datasets: dict or list or None</span>
<span class="sd">            A mapping from original filenames in `d` to the instances of</span>
<span class="sd">            :class:`xarray.Dataset` to use. If it is an iterable, the same</span>
<span class="sd">            holds as for the `alternative_paths` parameter</span>
<span class="sd">        pwd: str</span>
<span class="sd">            Path to the working directory from where the data can be imported.</span>
<span class="sd">            If None, use the current working directory.</span>
<span class="sd">        ignore_keys: list of str</span>
<span class="sd">            Keys specified in this list are ignored and not seen as array</span>
<span class="sd">            information (note that ``attrs`` are used anyway)</span>
<span class="sd">        only: string, list or callable</span>
<span class="sd">            Can be one of the following three things:</span>

<span class="sd">            - a string that represents a pattern to match the array names</span>
<span class="sd">              that shall be included</span>
<span class="sd">            - a list of array names to include</span>
<span class="sd">            - a callable with two arguments, a string and a dict such as</span>

<span class="sd">              .. code-block:: python</span>

<span class="sd">                  def filter_func(arr_name: str, info: dict): -&gt; bool</span>
<span class="sd">                      &#39;&#39;&#39;</span>
<span class="sd">                      Filter the array names</span>

<span class="sd">                      This function should return True if the array shall be</span>
<span class="sd">                      included, else False</span>

<span class="sd">                      Parameters</span>
<span class="sd">                      ----------</span>
<span class="sd">                      arr_name: str</span>
<span class="sd">                          The array name (i.e. the ``arr_name`` attribute)</span>
<span class="sd">                      info: dict</span>
<span class="sd">                          The dictionary with the array informations. Common</span>
<span class="sd">                          keys are ``&#39;name&#39;`` that points to the variable name</span>
<span class="sd">                          and ``&#39;dims&#39;`` that points to the dimensions and</span>
<span class="sd">                          ``&#39;fname&#39;`` that points to the file name</span>
<span class="sd">                      &#39;&#39;&#39;</span>
<span class="sd">                      return True or False</span>

<span class="sd">              The function should return ``True`` if the array shall be</span>
<span class="sd">              included, else ``False``. This function will also be given to</span>
<span class="sd">              subsequents instances of :class:`InteractiveList` objects that</span>
<span class="sd">              are contained in the returned value</span>
<span class="sd">        chname: dict</span>
<span class="sd">            A mapping from variable names in the project to variable names</span>
<span class="sd">            that should be used instead</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        ``**kwargs``</span>
<span class="sd">            Any other parameter from the `psyplot.data.open_dataset` function</span>
<span class="sd">        %(open_dataset.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        psyplot.data.ArrayList</span>
<span class="sd">            The list with the interactive objects</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_dataset, array_info&quot;&quot;&quot;</span>
        <span class="n">pwd</span> <span class="o">=</span> <span class="n">pwd</span> <span class="ow">or</span> <span class="n">getcwd</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">only_filter</span><span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">only</span><span class="p">):</span>
            <span class="n">only_filter</span> <span class="o">=</span> <span class="n">only</span>
        <span class="k">elif</span> <span class="n">isstring</span><span class="p">(</span><span class="n">only</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">only_filter</span><span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">patt</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">arr_name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">patt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">only</span><span class="p">)</span>
            <span class="n">only</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">only_filter</span><span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arr_name</span> <span class="ow">in</span> <span class="n">save_only</span>
            <span class="n">save_only</span> <span class="o">=</span> <span class="n">only</span>
            <span class="n">only</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">get_fname_use</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="n">squeeze</span> <span class="o">=</span> <span class="n">isstring</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">safe_list</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">f</span> <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_remote_url</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">or</span> <span class="n">osp</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">else</span>
                        <span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pwd</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">squeeze</span> <span class="k">else</span> <span class="n">ret</span>

        <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isstring</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">chname</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alternative_paths</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">alternative_paths</span><span class="p">)</span>
            <span class="n">alternative_paths</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="c1"># first open all datasets if not already done</span>
        <span class="k">if</span> <span class="n">datasets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">replace_concat_dim</span> <span class="o">=</span> <span class="s1">&#39;concat_dim&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="n">replace_combine</span> <span class="o">=</span> <span class="s1">&#39;combine&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>

            <span class="n">names_and_stores</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_dsnames</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">concat_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="p">(</span><span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">),</span> <span class="n">concat_dim</span><span class="p">,</span> <span class="n">combine</span> <span class="ow">in</span> <span class="n">names_and_stores</span><span class="p">:</span>
                <span class="n">fname_use</span> <span class="o">=</span> <span class="n">fname</span>
                <span class="n">got</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">replace_concat_dim</span> <span class="ow">and</span> <span class="n">concat_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;concat_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">concat_dim</span>
                <span class="k">elif</span> <span class="n">replace_concat_dim</span> <span class="ow">and</span> <span class="n">concat_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;concat_dim&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">replace_combine</span> <span class="ow">and</span> <span class="n">combine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;combine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">combine</span>
                <span class="k">elif</span> <span class="n">replace_combine</span> <span class="ow">and</span> <span class="n">combine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;combine&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fname_use</span> <span class="o">=</span> <span class="n">alternative_paths</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">got</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">got</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fname_use</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">fname_use</span> <span class="o">=</span> <span class="n">get_fname_use</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fname_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">datasets</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">_open_ds_from_store</span><span class="p">(</span>
                        <span class="n">fname_use</span><span class="p">,</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alternative_paths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">alternative_paths</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">datasets</span><span class="p">):</span>
                    <span class="n">datasets</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">_open_ds_from_store</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">it_datasets</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">it_datasets</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">arr_name</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr_name</span> <span class="ow">in</span> <span class="n">ignore_keys</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">only_filter</span><span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;arr&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
                <span class="c1"># the described object is an InteractiveList</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">InteractiveList</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                    <span class="n">info</span><span class="p">,</span> <span class="n">alternative_paths</span><span class="o">=</span><span class="n">alternative_paths</span><span class="p">,</span>
                    <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span> <span class="n">chname</span><span class="o">=</span><span class="n">chname</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Skipping empty list </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="n">arr_name</span><span class="p">)</span>
                    <span class="n">arrays</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;arr&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;arr&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s1">&#39;ds&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span>
                        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">],</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">get_name</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not open array </span><span class="si">%s</span><span class="s2"> because no filename was &quot;</span>
                             <span class="s2">&quot;specified!&quot;</span> <span class="o">%</span> <span class="n">arr_name</span><span class="p">)</span>
                        <span class="n">arrays</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">try</span><span class="p">:</span>  <span class="c1"># in case, datasets is a defaultdict</span>
                        <span class="n">datasets</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">if</span> <span class="n">fname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not open array </span><span class="si">%s</span><span class="s2"> because </span><span class="si">%s</span><span class="s2"> was not in &quot;</span>
                             <span class="s2">&quot;the list of datasets!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>
                        <span class="n">arrays</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span>
                        <span class="n">datasets</span><span class="p">[</span><span class="n">fname</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">],</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">get_name</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attrs&#39;</span><span class="p">,</span> <span class="p">{})):</span>
                    <span class="n">arr</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">=</span> <span class="n">arr_name</span>
            <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attrs&#39;</span><span class="p">,</span> <span class="p">{}))</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span><span class="s1">&#39;get_filename_ds.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;dump&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayList.array_info"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.array_info">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList.array_info&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">array_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">standardize_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_rel_paths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">alternative_paths</span><span class="o">=</span><span class="p">{},</span> <span class="n">ds_description</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;store&#39;</span><span class="p">},</span>
                   <span class="n">full_ds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get dimension informations on you arrays</span>

<span class="sd">        This method returns a dictionary containing informations on the</span>
<span class="sd">        array in this instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dump: bool</span>
<span class="sd">            If True and the dataset has not been dumped so far, it is dumped to</span>
<span class="sd">            a temporary file or the one generated by `paths` is used. If it is</span>
<span class="sd">            False or both, `dump` and `paths` are None, no data will be stored.</span>
<span class="sd">            If it is None and `paths` is not None, `dump` is set to True.</span>
<span class="sd">        %(get_filename_ds.parameters.no_ds|dump)s</span>
<span class="sd">        attrs: bool, optional</span>
<span class="sd">            If True (default), the :attr:`ArrayList.attrs` and</span>
<span class="sd">            :attr:`xarray.DataArray.attrs` attributes are included in the</span>
<span class="sd">            returning dictionary</span>
<span class="sd">        standardize_dims: bool, optional</span>
<span class="sd">            If True (default), the real dimension names in the dataset are</span>
<span class="sd">            replaced by x, y, z and t to be more general.</span>
<span class="sd">        pwd: str</span>
<span class="sd">            Path to the working directory from where the data can be imported.</span>
<span class="sd">            If None, use the current working directory.</span>
<span class="sd">        use_rel_paths: bool, optional</span>
<span class="sd">            If True (default), paths relative to the current working directory</span>
<span class="sd">            are used. Otherwise absolute paths to `pwd` are used</span>
<span class="sd">        ds_description: &#39;all&#39; or set of {&#39;fname&#39;, &#39;ds&#39;, &#39;num&#39;, &#39;arr&#39;, &#39;store&#39;}</span>
<span class="sd">            Keys to describe the datasets of the arrays. If all, all keys</span>
<span class="sd">            are used. The key descriptions are</span>

<span class="sd">            fname</span>
<span class="sd">                the file name is inserted in the ``&#39;fname&#39;`` key</span>
<span class="sd">            store</span>
<span class="sd">                the data store class and module is inserted in the ``&#39;store&#39;``</span>
<span class="sd">                key</span>
<span class="sd">            ds</span>
<span class="sd">                the dataset is inserted in the ``&#39;ds&#39;`` key</span>
<span class="sd">            num</span>
<span class="sd">                The unique number assigned to the dataset is inserted in the</span>
<span class="sd">                ``&#39;num&#39;`` key</span>
<span class="sd">            arr</span>
<span class="sd">                The array itself is inserted in the ``&#39;arr&#39;`` key</span>
<span class="sd">        full_ds: bool</span>
<span class="sd">            If True and ``&#39;ds&#39;`` is in `ds_description`, the entire dataset is</span>
<span class="sd">            included. Otherwise, only the DataArray converted to a dataset is</span>
<span class="sd">            included</span>
<span class="sd">        copy: bool</span>
<span class="sd">            If True, the arrays and datasets are deep copied</span>


<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(get_filename_ds.other_parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OrderedDict</span>
<span class="sd">            An ordered mapping from array names to dimensions and filename</span>
<span class="sd">            corresponding to the array</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_dict&quot;&quot;&quot;</span>
        <span class="n">saved_ds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_saved_ds&#39;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">def</span> <span class="nf">get_alternative</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">osp</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">alternative_paths</span><span class="p">)),</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="n">f</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">copy_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="c1"># try to get the number of the dataset and create only one copy</span>
                <span class="c1"># copy for each dataset</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">num</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">saved_ds</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">saved_ds</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">saved_ds</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">copy_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ds_description</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">ds_description</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;arr&#39;</span><span class="p">,</span> <span class="s1">&#39;store&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">paths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dump</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dump</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">pwd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pwd</span> <span class="o">=</span> <span class="n">getcwd</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">):</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">arr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">array_info</span><span class="p">(</span>
                    <span class="n">dump</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">pwd</span><span class="o">=</span><span class="n">pwd</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
                    <span class="n">standardize_dims</span><span class="o">=</span><span class="n">standardize_dims</span><span class="p">,</span>
                    <span class="n">use_rel_paths</span><span class="o">=</span><span class="n">use_rel_paths</span><span class="p">,</span> <span class="n">ds_description</span><span class="o">=</span><span class="n">ds_description</span><span class="p">,</span>
                    <span class="n">alternative_paths</span><span class="o">=</span><span class="n">alternative_paths</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">_saved_ds</span><span class="o">=</span><span class="n">saved_ds</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">standardize_dims</span><span class="p">:</span>
                    <span class="n">idims</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">standardize_dims</span><span class="p">(</span>
                        <span class="nb">next</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">iter_base_variables</span><span class="p">),</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">idims</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idims</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">idims</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dims&#39;</span><span class="p">:</span> <span class="n">idims</span><span class="p">}</span>
                <span class="k">if</span> <span class="s1">&#39;variable&#39;</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="s1">&#39;fname&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span> <span class="ow">or</span> <span class="s1">&#39;store&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span><span class="p">:</span>
                    <span class="n">fname</span><span class="p">,</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span> <span class="o">=</span> <span class="n">get_filename_ds</span><span class="p">(</span>
                        <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="n">dump</span><span class="p">,</span> <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;store&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;store&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;fname&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">safe_list</span><span class="p">(</span><span class="n">fname</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_remote_url</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>
                                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">found</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">get_alternative</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">use_rel_paths</span><span class="p">:</span>
                                    <span class="n">f</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pwd</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">f</span> <span class="o">=</span> <span class="n">osp</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span>
                                                       <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">safe_list</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_concat_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;concat_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_concat_dim</span>
                        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_combine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;combine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_combine</span>
                <span class="k">if</span> <span class="s1">&#39;ds&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">full_ds</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy_obj</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy_obj</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">())</span>
                <span class="k">if</span> <span class="s1">&#39;num&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">num</span>
                <span class="k">if</span> <span class="s1">&#39;arr&#39;</span> <span class="ow">in</span> <span class="n">ds_description</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;arr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy_obj</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">attrs</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;attrs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">attrs</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;attrs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_get_tnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the time coordinate of the objects in this list&quot;&quot;&quot;</span>
        <span class="n">tnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">):</span>
                <span class="n">tnames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">get_tnames</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tnames</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_tname</span><span class="p">(</span>
                    <span class="nb">next</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">iter_base_variables</span><span class="p">),</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tnames</span> <span class="o">-</span> <span class="p">{</span><span class="kc">None</span><span class="p">}</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_register_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span>
                         <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register new dimensions and formatoptions for updating. The keywords</span>
<span class="sd">        are the same as for each single array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveArray._register_update.parameters)s&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="n">replot</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                                     <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayList.start_update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.start_update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList.start_update&#39;</span><span class="p">)</span>
    <span class="nd">@dedent</span>
    <span class="k">def</span> <span class="nf">start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conduct the registered plot updates</span>

<span class="sd">        This method starts the updates from what has been registered by the</span>
<span class="sd">        :meth:`update` method. You can call this method if you did not set the</span>
<span class="sd">        `auto_update` parameter when calling the :meth:`update` method to True</span>
<span class="sd">        and when the :attr:`no_auto_update` attribute is True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        draw: bool or None</span>
<span class="sd">            If True, all the figures of the arrays contained in this list will</span>
<span class="sd">            be drawn at the end. If None, it defaults to the `&#39;auto_draw&#39;``</span>
<span class="sd">            parameter in the :attr:`psyplot.rcParams` dictionary</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`no_auto_update`, update&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">results</span><span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span>
                <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="n">queues</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">arr</span><span class="p">,),</span>
                          <span class="n">name</span><span class="o">=</span><span class="s1">&#39;update_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_njobs</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="p">[</span><span class="n">Queue</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">jobs</span><span class="p">)))]</span>
        <span class="c1"># populate the queues</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jobs</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">queues</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
            <span class="n">thread</span><span class="o">.</span><span class="n">setDaemon</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
            <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
            <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">draw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;auto_draw&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">(</span><span class="n">arr_name</span><span class="o">=</span><span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">adraw</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">adraw</span><span class="p">])</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;auto_show&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">keep_params</span><span class="p">(</span><span class="s1">&#39;InteractiveArray.update.parameters&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;auto_update&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayList.update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">get_sections</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s1">&#39;ArrayList.update&#39;</span><span class="p">)</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">auto_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">enable_post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the coordinates and the plot</span>

<span class="sd">        This method updates all arrays in this list with the given coordinate</span>
<span class="sd">        values and formatoptions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveArray._register_update.parameters)s</span>
<span class="sd">        %(InteractiveArray.update.parameters.auto_update)s</span>
<span class="sd">        %(ArrayList.start_update.parameters)s</span>
<span class="sd">        enable_post: bool</span>
<span class="sd">            If not None, enable (``True``) or disable (``False``) the</span>
<span class="sd">            :attr:`~psyplot.plotter.Plotter.post`  formatoption in the plotters</span>
<span class="sd">        ``**kwargs``</span>
<span class="sd">            Any other formatoption or dimension that shall be updated</span>
<span class="sd">            (additionally to those in `fmt` and `dims`)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(InteractiveArray.update.notes)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        no_auto_update, start_update&quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
        <span class="n">vars_and_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">]))</span>
        <span class="n">furtherdims</span><span class="p">,</span> <span class="n">furtherfmt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">vars_and_coords</span><span class="p">)</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">furtherdims</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">furtherfmt</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="n">replot</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span>
                              <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">enable_post</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_plotter</span><span class="p">:</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">enable_post</span> <span class="o">=</span> <span class="n">enable_post</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_auto_update</span> <span class="ow">or</span> <span class="n">auto_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="n">draw</span><span class="p">)</span></div>

<div class="viewcode-block" id="ArrayList.draw"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws all the figures in this instance&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fig</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">figs2draw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_plotter</span><span class="p">))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Drawing figure </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fig</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">_figs2draw</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Done drawing.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">fmts</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the arrays specified by their attributes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        types: type or tuple of types</span>
<span class="sd">            Any class that shall be used for an instance check via</span>
<span class="sd">            :func:`isinstance`. If not None, the :attr:`plotter` attribute</span>
<span class="sd">            of the array is checked against this `types`</span>
<span class="sd">        method: {&#39;isel&#39;, &#39;sel&#39;}</span>
<span class="sd">            Selection method for the dimensions in the arrays to be used.</span>
<span class="sd">            If `method` is &#39;isel&#39;, dimension values in `attrs` must correspond</span>
<span class="sd">            to integer values as they are found in the</span>
<span class="sd">            :attr:`InteractiveArray.idims` attribute.</span>
<span class="sd">            Otherwise the :meth:`xarray.DataArray.coords` attribute is used.</span>
<span class="sd">        fmts: list</span>
<span class="sd">            List of formatoption strings. Only arrays with plotters who have</span>
<span class="sd">            this formatoption are returned</span>
<span class="sd">        ``**attrs``</span>
<span class="sd">            Parameters may be any attribute of the arrays in this instance,</span>
<span class="sd">            including the matplotlib axes (``ax``), matplotlib figure</span>
<span class="sd">            (``fig``) and the array name (``arr_name``).</span>
<span class="sd">            Values may be iterables (e.g. lists) of the attributes to consider</span>
<span class="sd">            or callable functions that accept the attribute as a value. If the</span>
<span class="sd">            value is a string, it will be put into a list.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">safe_item_list</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">safe_list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">filter_list</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">other_attrs</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">arr_names</span> <span class="o">=</span> <span class="n">other_attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;arr_name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">arr_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">arr_names</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">arr_names</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="ow">in</span> <span class="n">arr_names</span><span class="p">))</span> <span class="ow">and</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">(</span><span class="n">types</span><span class="o">=</span><span class="n">types</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">other_attrs</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">filter_by_attrs</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sel&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">filter_by_attrs</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">filter_list</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">tname</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">get_tname</span><span class="p">(</span>
                    <span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)))</span>

                <span class="k">def</span> <span class="nf">check_values</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;arr_name&#39;</span><span class="p">:</span>
                        <span class="n">attr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;ax&#39;</span><span class="p">:</span>
                        <span class="n">attr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">ax</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;fig&#39;</span><span class="p">:</span>
                        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;figure&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>  <span class="c1"># do not filter for multiple items</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="p">,</span> <span class="s1">&#39;decoder&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">tname</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">in</span> <span class="n">vals</span>
                    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">vals</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">vals</span>
                <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">check_values</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span>
                        <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span>
                            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)),</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">check_values</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;arr_name&#39;</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;ax&#39;</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">ax</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;fig&#39;</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;figure&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">idims</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>  <span class="c1"># do not filter for multiple items</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">vals</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">vals</span>

            <span class="k">def</span> <span class="nf">filter_by_attrs</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">filter_list</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">check_values</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span>
                        <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">correct_dims</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span>
                            <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base_variables</span><span class="p">)),</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">safe_item_list</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">attrs</span><span class="p">)))</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="c1"># iterable</span>
            <span class="p">(</span><span class="n">arr</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span>
             <span class="p">(</span><span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span><span class="p">,</span> <span class="n">types</span><span class="p">))</span> <span class="ow">and</span>
             <span class="n">filter_by_attrs</span><span class="p">(</span><span class="n">arr</span><span class="p">)),</span>
            <span class="c1"># give itself as base and the auto_update parameter</span>
            <span class="n">auto_update</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_update</span><span class="p">))</span>
        <span class="c1"># now filter for the formatoptions</span>
        <span class="k">if</span> <span class="n">fmts</span><span class="p">:</span>
            <span class="n">fmts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">safe_list</span><span class="p">(</span><span class="n">fmts</span><span class="p">))</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span> <span class="ow">and</span>
                                    <span class="n">fmts</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">plotter</span><span class="p">)),</span>
                       <span class="n">ret</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_names</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">isstring</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_array</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_contains_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks whether exactly this array is in the list&quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">arr_name</span><span class="o">=</span><span class="n">val</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">is_not_list</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">),</span>
                <span class="p">[</span><span class="n">arr</span><span class="p">,</span> <span class="n">val</span><span class="p">]))</span>
        <span class="n">is_list</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">InteractiveList</span><span class="p">),</span>
                          <span class="p">[</span><span class="n">arr</span><span class="p">,</span> <span class="n">val</span><span class="p">]))</span>
        <span class="c1"># if one is an InteractiveList and the other not, they differ</span>
        <span class="k">if</span> <span class="n">is_list</span> <span class="ow">and</span> <span class="n">is_not_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># if both are interactive lists, check the lists</span>
        <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">in</span> <span class="n">val</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">)</span>
        <span class="c1"># else we check the shapes and values</span>
        <span class="k">return</span> <span class="n">arr</span> <span class="ow">is</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">_short_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intend</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maybe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">maybe</span><span class="p">:</span>
            <span class="n">intend</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">str_intend</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">intend</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">str_intend</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;arr_name&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_short_info</span><span class="p">(</span><span class="n">intend</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="n">maybe</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">str_intend</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">([</span><span class="se">\n</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;arr_name&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">_short_info</span><span class="p">(</span><span class="n">intend</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_short_info</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overwrites lists __getitem__ by returning an ArrayList if `key` is a</span>
<span class="sd">        slice&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>  <span class="c1"># return a new ArrayList</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ArrayList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># return the item</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ArrayList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>  <span class="c1"># for compatibility to python 2.7</span>
        <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span>

<div class="viewcode-block" id="ArrayList.next_available_name"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.next_available_name">[docs]</a>    <span class="k">def</span> <span class="nf">next_available_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt_str</span><span class="o">=</span><span class="s1">&#39;arr</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new array out of the given format string</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        format_str: str</span>
<span class="sd">            The base string to use. ``&#39;{0}&#39;`` will be replaced by a counter</span>
<span class="sd">        counter: iterable</span>
<span class="sd">            An iterable where the numbers should be drawn from. If None,</span>
<span class="sd">            ``range(100)`` is used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A possible name that is not in the current project&quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_names</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="ow">or</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">,</span>
                       <span class="nb">map</span><span class="p">(</span><span class="n">fmt_str</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">counter</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> already in the list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fmt_str</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_name</span></div>

<div class="viewcode-block" id="ArrayList.append"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.append">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a new array to the list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value: InteractiveBase</span>
<span class="sd">            The data object to append to this list</span>
<span class="sd">        %(ArrayList.rename.parameters.new_name)s</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        %(ArrayList.rename.raises)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        list.append, extend, rename&quot;&quot;&quot;</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">renamed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">renamed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ArrayList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="ArrayList.extend"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.extend">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add further arrays from an iterable to this list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable</span>
<span class="sd">            Any iterable that contains :class:`InteractiveBase` instances</span>
<span class="sd">        %(ArrayList.rename.parameters.new_name)s</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        %(ArrayList.rename.raises)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        list.extend, append, rename&quot;&quot;&quot;</span>
        <span class="c1"># extend those arrays that aren&#39;t alredy in the list</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ArrayList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ArrayList.remove"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.ArrayList.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an array from the list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr: str or :class:`InteractiveBase`</span>
<span class="sd">            The array name or the data object in this list to remove</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no array with the specified array name is in the list&quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">arr</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="k">else</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Array </span><span class="si">{0}</span><span class="s2"> not in the list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;No array found with name </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="DatasetAccessor"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.DatasetAccessor">[docs]</a><span class="nd">@xr</span><span class="o">.</span><span class="n">register_dataset_accessor</span><span class="p">(</span><span class="s1">&#39;psy&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DatasetAccessor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A dataset accessor to interface with the psyplot package&quot;&quot;&quot;</span>

    <span class="n">_filename</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_data_store</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_num</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_plot</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#: The concatenation dimension for datasets opened with open_mfdataset</span>
    <span class="n">_concat_dim</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#: The combine method to open multiple datasets with open_mfdataset</span>
    <span class="n">_combine</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A unique number for the dataset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_ds_counter</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num</span>

    <span class="nd">@num</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An object to generate new plots from this dataset</span>

<span class="sd">        To make a 2D-plot with the :mod:`psy-simple &lt;psy_simple.plugin&gt;`</span>
<span class="sd">        plugin, you can just type</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            project = ds.psy.plot.plot2d(name=&#39;variable-name&#39;)</span>

<span class="sd">        It will create a new subproject with the extracted and visualized data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        psyplot.project.DatasetPlotter: for the different plot methods</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">psyplot.project</span> <span class="k">as</span> <span class="nn">psy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span> <span class="o">=</span> <span class="n">psy</span><span class="o">.</span><span class="n">DatasetPlotter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the file that stores this dataset&quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>
        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">get_filename_ds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fname</span>

    <span class="nd">@filename</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_store</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`xarray.backends.common.AbstractStore` used to save the</span>
<span class="sd">        dataset&quot;&quot;&quot;</span>
        <span class="n">store_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_store</span>
        <span class="k">if</span> <span class="n">store_info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">store_info</span><span class="p">):</span>
            <span class="n">store</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="s1">&#39;_file_obj&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">store_mod</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__module__</span> <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">store_cls</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span>
        <span class="k">return</span> <span class="n">store_info</span>

    <span class="nd">@data_store</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_store</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="DatasetAccessor.create_list"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.DatasetAccessor.create_list">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">create_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a :class:`psyplot.data.ArrayList` with arrays from this dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(ArrayList.from_dataset.parameters)s</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(ArrayList.from_dataset.other_parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(ArrayList.from_dataset.returns)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        psyplot.data.ArrayList.from_dataset&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArrayList</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="DatasetAccessor.to_array"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.DatasetAccessor.to_array">[docs]</a>    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as :meth:`xarray.Dataset.to_array` but sets the base&quot;&quot;&quot;</span>
        <span class="c1"># the docstring is set below</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="n">to_array</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">to_array</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">!=</span> <span class="s1">&#39;ds&#39;</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has not Attribute </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

<div class="viewcode-block" id="DatasetAccessor.copy"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.DatasetAccessor.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the array</span>

<span class="sd">        This method returns a copy of the underlying array in the :attr:`arr`</span>
<span class="sd">        attribute. It is more stable because it creates a new `psy` accessor&quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="p">)</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">psy</span> <span class="o">=</span> <span class="n">DatasetAccessor</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span></div></div>


<div class="viewcode-block" id="InteractiveList"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList">[docs]</a><span class="k">class</span> <span class="nc">InteractiveList</span><span class="p">(</span><span class="n">ArrayList</span><span class="p">,</span> <span class="n">InteractiveBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List of :class:`InteractiveArray` instances that can be plotted itself</span>

<span class="sd">    This class combines the :class:`ArrayList` and the interactive plotting</span>
<span class="sd">    through :class:`psyplot.plotter.Plotter` classes. It is mainly used by the</span>
<span class="sd">    :mod:`psyplot.plotter.simple` module&quot;&quot;&quot;</span>

    <span class="n">no_auto_update</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_no_auto_update_getter</span><span class="p">,</span>
                              <span class="n">doc</span><span class="o">=</span><span class="n">_no_auto_update_getter</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="nd">@no_auto_update</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">no_auto_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">ArrayList</span><span class="o">.</span><span class="n">no_auto_update</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">no_auto_update</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@docstrings</span>
    <span class="k">def</span> <span class="nf">_njobs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;%(InteractiveBase._njobs)s&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_njobs</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">psy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list itself&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">logger</span>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span><span class="s1">&#39;InteractiveBase.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;auto_update&#39;</span><span class="p">)</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(ArrayList.parameters)s</span>
<span class="sd">        %(InteractiveBase.parameters.no_auto_update)s&quot;&quot;&quot;</span>
        <span class="n">ibase_kwargs</span><span class="p">,</span> <span class="n">array_kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_kwargs</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;plotter&#39;</span><span class="p">,</span> <span class="s1">&#39;arr_name&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registered_updates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">InteractiveBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ibase_kwargs</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_signals</span><span class="p">:</span>
            <span class="n">ArrayList</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">_register_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;isel&#39;</span><span class="p">,</span> <span class="n">replot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">{},</span> <span class="n">fmt</span><span class="o">=</span><span class="p">{},</span>
                         <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register new dimensions and formatoptions for updating</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveArray._register_update.parameters)s&quot;&quot;&quot;</span>
        <span class="n">ArrayList</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">_register_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">todefault</span><span class="o">=</span><span class="n">todefault</span><span class="p">,</span>
                                         <span class="n">replot</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="ow">or</span> <span class="n">replot</span><span class="p">,</span>
                                         <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

<div class="viewcode-block" id="InteractiveList.start_update"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList.start_update">[docs]</a>    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conduct the formerly registered updates</span>

<span class="sd">        This method conducts the updates that have been registered via the</span>
<span class="sd">        :meth:`update` method. You can call this method if the</span>
<span class="sd">        :attr:`auto_update` attribute of this instance is True and the</span>
<span class="sd">        `auto_update` parameter in the :meth:`update` method has been set to</span>
<span class="sd">        False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(InteractiveBase.start_update.parameters)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(InteractiveBase.start_update.returns)s</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`no_auto_update`, update</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">queues</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onupdate</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finish_all</span><span class="p">(</span><span class="n">queues</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">queues</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">InteractiveBase</span><span class="o">.</span><span class="n">start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">queues</span><span class="o">=</span><span class="n">queues</span><span class="p">)</span></div>

<div class="viewcode-block" id="InteractiveList.to_dataframe"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">to_df</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;to_frame&#39;</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_names</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">arr</span><span class="o">.</span><span class="n">psy</span><span class="o">.</span><span class="n">arr_name</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep_names</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">to_df</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">to_df</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span></div>

    <span class="n">docstrings</span><span class="o">.</span><span class="n">delete_params</span><span class="p">(</span><span class="s1">&#39;ArrayList.from_dataset.parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;plotter&#39;</span><span class="p">)</span>
    <span class="n">docstrings</span><span class="o">.</span><span class="n">delete_kwargs</span><span class="p">(</span><span class="s1">&#39;ArrayList.from_dataset.other_parameters&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="InteractiveList.from_dataset"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList.from_dataset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@docstrings</span><span class="o">.</span><span class="n">dedent</span>
    <span class="k">def</span> <span class="nf">from_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InteractiveList instance from the given base dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(ArrayList.from_dataset.parameters.no_plotter)s</span>
<span class="sd">        plotter: psyplot.plotter.Plotter</span>
<span class="sd">            The plotter instance that is used to visualize the data in this</span>
<span class="sd">            list</span>
<span class="sd">        make_plot: bool</span>
<span class="sd">            If True, the plot is made</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        %(ArrayList.from_dataset.other_parameters.no_args_kwargs)s</span>
<span class="sd">        ``**kwargs``</span>
<span class="sd">            Further keyword arguments may point to any of the dimensions of the</span>
<span class="sd">            data (see `dims`)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        %(ArrayList.from_dataset.returns)s&quot;&quot;&quot;</span>
        <span class="n">plotter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;plotter&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">make_plot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_plot&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">InteractiveList</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plotter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">initialize_plot</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">make_plot</span><span class="o">=</span><span class="n">make_plot</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span></div>

<div class="viewcode-block" id="InteractiveList.extend"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># reimplemented to emit onupdate</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InteractiveList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onupdate</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span></div>

<div class="viewcode-block" id="InteractiveList.append"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># reimplemented to emit onupdate</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InteractiveList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onupdate</span><span class="o">.</span><span class="n">emit</span><span class="p">()</span></div>

<div class="viewcode-block" id="InteractiveList.to_interactive_list"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.InteractiveList.to_interactive_list">[docs]</a>    <span class="k">def</span> <span class="nf">to_interactive_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<span class="k">class</span> <span class="nc">_MissingModule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class that can be used if an optional module is not avaible.</span>

<span class="sd">    This class raises an error if any attribute is accessed or it is called&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error: ImportError</span>
<span class="sd">            The error that has been raised when tried to import the module&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>


<span class="k">def</span> <span class="nf">_open_ds_from_store</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">store_mod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Open a dataset and return it&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fname</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isstring</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># test iterable</span>
            <span class="n">fname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">store_mod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">store_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">store_mod</span><span class="p">):</span>
                    <span class="n">store_mod</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">store_mod</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">isstring</span><span class="p">(</span><span class="n">store_cls</span><span class="p">):</span>
                    <span class="n">store_cls</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">store_cls</span><span class="p">)</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="p">[</span><span class="n">_open_store</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">sm</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">)]</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;engine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lock&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">open_mfdataset</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># try guessing with open_dataset</span>
                <span class="k">return</span> <span class="n">open_mfdataset</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">store_mod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">store_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">_open_store</span><span class="p">(</span><span class="n">store_mod</span><span class="p">,</span> <span class="n">store_cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">open_dataset</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="decode_absolute_time"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.decode_absolute_time">[docs]</a><span class="k">def</span> <span class="nf">decode_absolute_time</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">day</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">day</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">sub</span><span class="p">)</span>
        <span class="c1"># round microseconds</span>
        <span class="k">if</span> <span class="n">rest</span><span class="o">.</span><span class="n">microseconds</span><span class="p">:</span>
            <span class="n">rest</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">microseconds</span><span class="o">=</span><span class="mf">1e6</span> <span class="o">-</span> <span class="n">rest</span><span class="o">.</span><span class="n">microseconds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">day</span><span class="p">,</span> <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">rest</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">decode</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">])(</span><span class="n">times</span><span class="p">)</span></div>


<div class="viewcode-block" id="encode_absolute_time"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.encode_absolute_time">[docs]</a><span class="k">def</span> <span class="nf">encode_absolute_time</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">t</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">day</span><span class="p">))</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mf">86400.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">encode</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">])(</span><span class="n">times</span><span class="p">)</span></div>


<div class="viewcode-block" id="AbsoluteTimeDecoder"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.AbsoluteTimeDecoder">[docs]</a><span class="k">class</span> <span class="nc">AbsoluteTimeDecoder</span><span class="p">(</span><span class="n">NDArrayMixin</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>
        <span class="n">example_value</span> <span class="o">=</span> <span class="n">first_n_items</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">decode_absolute_time</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not interprete absolute time values!&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">decode_absolute_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>


<div class="viewcode-block" id="AbsoluteTimeEncoder"><a class="viewcode-back" href="../../api/psyplot.data.html#psyplot.data.AbsoluteTimeEncoder">[docs]</a><span class="k">class</span> <span class="nc">AbsoluteTimeEncoder</span><span class="p">(</span><span class="n">NDArrayMixin</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>
        <span class="n">example_value</span> <span class="o">=</span> <span class="n">first_n_items</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">encode_absolute_time</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not interprete absolute time values!&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">encode_absolute_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 Helmholtz-Zentrum Hereon, 2020-2021 Helmholtz-Zentrum Geesthacht, 2016-2021 University of Lausanne.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>